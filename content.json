{"meta":{"title":"Daniel Blog","subtitle":"","description":"It is the new beginning of coding!","author":"Daniel Lin","url":"http://daniellin0516.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-07-18T16:16:50.000Z","updated":"2021-07-18T16:45:04.989Z","comments":true,"path":"categories/index.html","permalink":"http://daniellin0516.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-07-18T16:56:43.000Z","updated":"2021-07-19T01:55:22.431Z","comments":false,"path":"about/index.html","permalink":"http://daniellin0516.github.io/about/index.html","excerpt":"","text":"本人刚接触编程~现在为大连理工大学的一名大三学生 12345678public Class Coding&#123; public static void main() &#123; System.out.println(&quot;Start Coding……&quot;) &#125;&#125;"},{"title":"repositories","date":"2021-07-18T16:51:19.962Z","updated":"2021-07-18T16:51:19.962Z","comments":false,"path":"repository/index.html","permalink":"http://daniellin0516.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-18T16:21:13.000Z","updated":"2021-07-18T16:43:55.282Z","comments":false,"path":"tags/index.html","permalink":"http://daniellin0516.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数组专题（入门）","slug":"数组专题（入门）","date":"2021-09-19T02:42:30.000Z","updated":"2021-09-19T03:07:36.740Z","comments":true,"path":"2021/09/19/数组专题（入门）/","link":"","permalink":"http://daniellin0516.github.io/2021/09/19/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"","text":"数组1.存在重复元素给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 思路：先将数组按大小排好，利用sort()，然后在相邻之间进行比较是否要相同元素 12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var containsDuplicate = function(nums) &#123; nums.sort((a,b)=&gt;b-a); for(var i=0; i &lt; nums.length ; i++)&#123; if(nums[i] == nums[i+1])&#123; return true; &#125; &#125; return false; &#125; 2.最大子序和（动态规划）给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 思路： 这种方法称作正数增益，这样子就可以找到最大的和 12345678910111213var maxSubArray = function(nums) &#123; let ans = nums[0]; let sum = 0; for(const num of nums) &#123; if(sum &gt; 0) &#123; sum += num; &#125; else &#123; sum = num; &#125; ans = Math.max(ans, sum); &#125; return ans;&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"替换空格（字符串数组）","slug":"替换空格（字符串数组）","date":"2021-09-17T03:13:30.000Z","updated":"2021-09-17T03:34:36.453Z","comments":true,"path":"2021/09/17/替换空格（字符串数组）/","link":"","permalink":"http://daniellin0516.github.io/2021/09/17/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%EF%BC%89/","excerpt":"","text":"替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 思路一：利用字符串拼接(不推荐，因为 JS中字符串无法被修改，一旦给字符串变量重新赋值，就要花费时间和空间去重新新建一个字符串，从而增加了复杂度！) 12345678910111213141516/** * @param &#123;string&#125; s * @return &#123;string&#125; */var replaceSpace = function(s) &#123;var res = &#x27;&#x27;;for(var i = 0 ; i &lt; s.length ; i++)&#123; var ch = s[i]; if(s[i]==&#x27; &#x27;)&#123; res += &quot;%20&quot; ; &#125;else&#123; res = res + ch; &#125;&#125;return res;&#125;; 思路二： 将字符串转换为数组，然后统计其中的空格数量。 根据空格数量和原有字符串有效字符长度，计算出刚好存放替换后的字符长度的数组。 创建两个指针，一个指数组末尾，一个指字符串有效位的末尾，实现原地修改. 12345678910111213141516171819202122232425/** * @param &#123;string&#125; s * @return &#123;string&#125; */var replaceSpace = function(s) &#123; s = s.split(&quot;&quot;); let oldLen = s.length; let spaceCount = 0; for (let i = 0; i &lt; oldLen; i++) &#123; if (s[i] === &#x27; &#x27;) spaceCount++; &#125; s.length += spaceCount * 2; for (let i = oldLen - 1, j = s.length - 1; i &gt;= 0; i--, j--) &#123; if (s[i] !== &#x27; &#x27;) s[j] = s[i]; else &#123; s[j - 2] = &#x27;%&#x27;; s[j - 1] = &#x27;2&#x27;; s[j] = &#x27;0&#x27;; j -= 2; &#125; &#125; return s.join(&#x27;&#x27;);&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"包含min函数的栈","slug":"包含min函数的栈","date":"2021-09-15T04:19:52.000Z","updated":"2021-09-15T04:58:08.860Z","comments":true,"path":"2021/09/15/包含min函数的栈/","link":"","permalink":"http://daniellin0516.github.io/2021/09/15/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","excerpt":"","text":"包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 主要思路：利用两个栈 ，stack负责出栈入栈，另外一个作为辅助栈min_stack存储stack中的最小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * initialize your data structure here. */var MinStack = function() &#123;this.stack = [];this.minstack = [Infinity];&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.stack.push(x); this.minstack.push(Math.min(this.minstack[this.minstack.length - 1],x)); &#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123;this.stack.pop();this.minstack.pop();&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123;return this.stack[this.stack.length-1]; &#125;;/** * @return &#123;number&#125; */MinStack.prototype.min = function() &#123;return this.minstack[this.minstack.length-1];&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.min() */","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"用两个栈实现队列","slug":"用两个栈实现队列","date":"2021-09-14T10:19:08.000Z","updated":"2021-09-14T10:38:20.879Z","comments":true,"path":"2021/09/14/用两个栈实现队列/","link":"","permalink":"http://daniellin0516.github.io/2021/09/14/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 123456789101112131415161718192021222324252627282930var CQueue = function() &#123; this.stackA = []; //创建栈 this.stackB = []; //创建栈&#125;;/** * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123; this.stackA.push(value); //将栈A设为入队栈&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123; if(this.stackB.length)&#123; //判断栈B是否为空栈 return this.stackB.pop(); //将栈B的顶部移出（也就是A的入队元素移出） &#125;else&#123; while(this.stackA.length)&#123; this.stackB.push(this.stackA.pop()); //将A的栈顶元素推入栈底 &#125; if(!this.stackB.length)&#123; return -1; //若B为空栈返回-1 &#125;else&#123; return this.stackB.pop(); //返回B出栈元素 &#125; &#125;&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"跨域","slug":"跨域","date":"2021-09-12T08:50:12.000Z","updated":"2021-09-12T11:32:41.635Z","comments":true,"path":"2021/09/12/跨域/","link":"","permalink":"http://daniellin0516.github.io/2021/09/12/%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"同源策略同源策略最早由NETscape公司提出，是浏览器一种安全策略。 同源：协议、域名、端口号 必须完全相同 违背同源策略就是跨域 123456789101112131415const btn = document.querySelector(&quot;button&quot;); btn.onclick = function()&#123; const x = new XMLHttpRequest(); //这里因为是满足同源策略的,所以url可以简写 x.open(&quot;GET&quot;,&quot;/data&quot;); //发送 x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; if(x.status &gt;=200 &amp;&amp; x.status &lt; 300)&#123; console.log(x.response); &#125; &#125; &#125; &#125; 服务器后端 123456789101112const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/home&#x27;,(request,response)=&gt;&#123; //响应一个页面 response.sendFile(__dirname + &quot;/index.html&quot;);&#125;);app.get(&#x27;/data&#x27;,(request,response)=&gt;&#123; response.send(&quot;用户数据&quot;);&#125;);app.listen(9000,()=&gt;&#123; console.log(&quot;服务已经启动……&quot;);&#125;); 如何解决跨域1.JSONPJSONP是一个非官方的跨域解决方案，只支持get请求 通过script标签实现跨域 123456789&lt;script&gt; function handle(data)&#123; //获取 result元素 const result = document.getElementById(&quot;result&quot;); result.innerHTML = data.name;&#125; &lt;/script&gt; &lt;!-- &lt;script src=&quot;./js/app.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;http://127.0.0.1:8000/jsonp-server&quot;&gt;&lt;/script&gt; 后端js代码： 12345678910app.all(&#x27;/jsonp-server&#x27;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;helllo&quot;)&#x27;); //返回必须是js代码 const data = &#123; name:&quot;山硅谷&quot; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;) 原生JSONP实践 123456789101112131415161718192021222324252627&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; //获取input元素 const input = document.querySelector(&quot;input&quot;); const p = document.querySelector(&quot;p&quot;); //声明handle函数 function handle(data)&#123; input.style.border = &quot;solid 1px #f00&quot;; //修改p标签的提示文本 p.innerHTML = data.msg; &#125;; //绑定实践 input.onblur = function()&#123; //获取用户输入值 let username = this.value; //向服务器发送请求 检测用户名是否存在 //创建script标签 const script = document.createElement(&quot;script&quot;); //2.设置标签的src属性 script.src = &quot;http://127.0.0.1:8000/check-username&quot;; //3.将script插入到文档中 document.body.appendChild(script); &#125;; &lt;/script&gt;&lt;/body&gt; 后端JS 1234567891011app.all(&#x27;/check-username&#x27;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;helllo&quot;)&#x27;); //返回必须是js代码 const data = &#123; exist: 1, msg: &quot;用户名已经存在&quot; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;) JQuery发送jsonp请求12345678910111213141516&lt;body&gt; &lt;button&gt;点击发送jsonp请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; $(&quot;button&quot;).eq(0).click(function()&#123; $.getJSON(&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;,function(data)&#123; $(&quot;result&quot;).html(` 名称: $&#123;data.name&#125;&lt;br&gt; 校区: $&#123;data.city&#125; `) &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 1234567891011121314app.all(&#x27;/jquery-jsonp-server&#x27;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;helllo&quot;)&#x27;); //返回必须是js代码 const data = &#123; name:&quot;尚硅谷&quot;, city: [&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收callback参数 let cb = request.query.callback; //返回结果 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;) CORS跨域资源共享，cors是官方的跨域解决方案，它的特点是不需要在客户端任何特殊的操作，完全在服务期进行处理，支持get和post请求。 12345678910111213const btn = document.querySelector(&quot;button&quot;); btn.onclick = function()&#123; const x = new XMLHttpRequest(); x.open(&quot;GET&quot;,&quot;http://127.0.0.1:8000/cors-server&quot;); x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; if(x.status &gt;=200 &amp;&amp; x.status &lt; 300)&#123; console.log(x.response); &#125; &#125; &#125; &#125; 12345app.all(&#x27;/cors-server&#x27;,(request,response)=&gt;&#123; response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); // response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://127.0.0.1:5500&#x27;); response.send(&quot;hello cors&quot;);&#125;)","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"JQuery发送AJAX","slug":"JQuery发送AJAX","date":"2021-09-11T07:52:01.000Z","updated":"2021-09-11T10:58:47.889Z","comments":true,"path":"2021/09/11/JQuery发送AJAX/","link":"","permalink":"http://daniellin0516.github.io/2021/09/11/JQuery%E5%8F%91%E9%80%81AJAX/","excerpt":"","text":"JQuery发送AJAX请求GET请求12345$(&quot;button&quot;).eq(0).click(function()&#123; $.get(&quot;http://127.0.0.1:8000/jquery-server&quot;, &#123;a:100,b:200&#125;,function(data)&#123; console.log(data); &#125;,&#x27;json&#x27;); &#125;); POST请求12345$(&quot;button&quot;).eq(1).click(function()&#123; $.post(&quot;http://127.0.0.1:8000/jquery-server&quot;, &#123;a:100,b:200&#125;,function(data)&#123; console.log(data); &#125;); &#125;); 服务器后端设置： 123456app.all(&#x27;/jquery-server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); const data = &#123;name: &#x27;尚硅谷&#x27;&#125;; response.send(JSON.stringify(data));&#125;); 通用型方法AJAX123456789101112131415161718192021222324252627$(&quot;button&quot;).eq(2).click(function()&#123; $.ajax(&#123; //url url:&#x27;http://127.0.0.1:8000/jquery-server&#x27;, //参数 data:&#123;a:100,b:200&#125;, //请求类型 type:&#x27;GET&#x27;, //响应体结果 dataType:&#x27;json&#x27;, //成功的回调 success:function(data)&#123; console.log(data); &#125;, //超时时间 timeout: 2000, //失败的回调 error:function()&#123; console.log(&quot;出错啦！&quot;); &#125;, //头信息 headers:&#123; c:300, d:400 &#125; &#125;); &#125;); Axios发送Ajax请求GET请求1234567891011121314151617btns[0].onclick = function()&#123; //GET请求 axios.get(&quot;/axios-server&quot;,&#123; //url参数 params:&#123; id:100, vip:7, &#125;, //请求头信息 headers: &#123; name:&#x27;atguigu&#x27;, age:20 &#125; &#125;).then(value =&gt; &#123; console.log(value); &#125;); &#125;; POST请求1234567891011121314151617btns[1].onclick = function()&#123; axios.post(&quot;/axios-server&quot;,&#123; username:&quot;admin&quot;, password:&#x27;admin&#x27; &#125;,&#123; //url params: &#123; id:200, vip:9 &#125;, //请求头参数 headers: &#123; height:180, weight:180, &#125; &#125;); &#125; 通用型方法AJAX1234567891011121314151617181920212223242526272829303132btns[2].onclick = function()&#123; axios(&#123; //请求方法 method:&quot;POST&quot;, //url url:&quot;/axios-server&quot;, //url参数 params:&#123; vip:10, level:30 &#125;, headers:&#123; a:100, b:200 &#125;, //请求体参数 data:&#123; username:&quot;admin&quot;, password:&quot;admin&quot; &#125; &#125;).then(response=&gt;&#123; console.log(response); //响应状态码 console.log(response.status); //响应状态字符串 console.log(statusText); //响应头信息 console.log(response.headers); //响应体 console.log(response.data); &#125;) &#125;;","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"AJAX超时请求、取消请求、重复发送请求","slug":"AJAX超时请求、取消请求、重复发送请求","date":"2021-09-11T01:46:57.000Z","updated":"2021-09-11T02:21:53.436Z","comments":true,"path":"2021/09/11/AJAX超时请求、取消请求、重复发送请求/","link":"","permalink":"http://daniellin0516.github.io/2021/09/11/AJAX%E8%B6%85%E6%97%B6%E8%AF%B7%E6%B1%82%E3%80%81%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%E3%80%81%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","excerpt":"","text":"请求超时和网络异常处理前端设置 超时设置 12//超时设置xhr.timeout = 2000; 超时回调 123xhr.ontimeout = function()&#123; alert(&quot;网络异常，稍后重试&quot;);&#125; 网络异常回调 123xhr.onerror = function()&#123; alert(&quot;你的网络似乎出了点问题！&quot;);&#125; 后端设置123456789app.get(&#x27;/delay&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置定时器 setTimeout(()=&gt;&#123; response.send(&#x27;延时响应&#x27;); &#125;,3000) //设置响应体 &#125;); 取消请求前端设置利用abort函数 1xhr.abort()； 重复请求问题123456789101112131415161718let x = null;let isSending = false;//是否正在发送AJAX请求btn[0].onclick = function()&#123; //判断标识变量 if(isSending) x.abort(); //如果正在发送，则取消该请求，创建一个新的请求 x= new XMLHttpRequest(); //修改标识变量的值 isSending = true; x.open(&quot;GET&quot;,&quot;http://127.0.0.1:8000/delay&quot;); x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; //修改表示变量 isSending = false; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"服务端响应JSON数据","slug":"服务端响应JSON数据","date":"2021-09-10T12:33:49.000Z","updated":"2021-09-10T12:43:27.352Z","comments":true,"path":"2021/09/10/服务端响应JSON数据/","link":"","permalink":"http://daniellin0516.github.io/2021/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94JSON%E6%95%B0%E6%8D%AE/","excerpt":"","text":"响应JASON数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 3px #89b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const xhr = document.getElementById(&quot;result&quot;); window.onkeydown = function()&#123; //发送请求 const xhr = new XMLHttpRequest(); //设置响应体数据的类型 xhr.responseType = &quot;json&quot;; //初始化 xhr.open(&#x27;GET&#x27;,&#x27;http://127.0.0.1:8000/json-server&#x27;); //发送 xhr.send(); //事件绑定 xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; // console.log(xhr.response); // result.innerHTML = xhr.response; //1.手动对数据转化 // let data =JSON.parse(xhr.response); // console.log(data); // result.innerHTML = data.name; //2.自动转化 console.log(xhr.response); result.innerHTML = xhr.response.name; &#125; &#125; &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 传给服务器js文件 12345678910111213141516171819202122232425262728293031const express = require(&#x27;express&#x27;);//创建应用对象const app = express();//创建路由规则// request是对响应报文的封装//response是对响应报文的封装app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX&#x27;);&#125;);//可以接收任意类型的请求app.all(&#x27;/json-server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;); //响应一个数据 const data = &#123; name: &#x27;atguigu&#x27; &#125;; //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体 response.send(str);&#125;);//监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;)","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"原生AJAX发送请求","slug":"原生AJAX发送请求","date":"2021-09-10T07:24:52.000Z","updated":"2021-09-10T08:35:09.202Z","comments":true,"path":"2021/09/10/原生AJAX发送请求/","link":"","permalink":"http://daniellin0516.github.io/2021/09/10/%E5%8E%9F%E7%94%9FAJAX%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","excerpt":"","text":"GET请求1234567891011121314151617181920212223242526272829btn.onclick = function()&#123; //1.创建对象 const xhr = new XMLHttpRequest; //2.初始化 设置请求方法和url xhr.open(&#x27;GET&#x27;,&#x27;http://127.0.0:8000/server&#x27;); //3.发送 xhr.send(); //4.事件绑定 处理服务端返回的结果 //on when 当……时候 //readystate 是xhr对象中的属性，表示状态0 1 2 3 4 //change 改变 xhr.onreadyStatechange = function()&#123; //判断(服务端返回了所有结果) if(xhr.readyState === 4)&#123; //判断响应状态码 200 404 403 401 500 //2xx 成功 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; //处理结果 行 头 空行 体 //1.响应行 console.log(xhr.Status);//状态码 console.log(xhr.StatusText);//状态字符串 console.log(xhr.getAllResponseHeaders());//所有响应头 console.log(xhr.response);//响应体 &#125;else&#123; &#125; &#125; &#125; &#125;; 其中的server.js为下列代码： 1234567891011const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO EXPRESS&#x27;);&#125;);app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;) POST请求12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;AJAX POST&lt;/title&gt; &lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 1px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; //获取元素对象 const result = document.getElementById(&quot;result&quot;); //绑定事件 result.addEventListener(&quot;mouseover&quot;,function()&#123; //1.创建对象 const xhr = new XMLHttpRequest(); //2.初始化 设置类型与URL xhr.open(&#x27;POST&#x27;,&#x27;http://127.0.0.1:8000/server&#x27;); //3.发送 xhr.send(); //4.事件绑定 xhr.onreadystatechange = function()&#123; //判断 if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt;300)&#123; //处理服务端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其中的server.js为下列代码： 12345678910111213141516171819202122const express = require(&#x27;express&#x27;);//创建应用对象const app = express();//创建路由规则// request是对响应报文的封装//response是对响应报文的封装app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX&#x27;);&#125;);app.post(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);//监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;) POST设置请求体123xhr.send(&quot;a=100&amp;b=200&amp;c=300&quot;);//或者xhr.send(&quot;a:100&amp;b:200&amp;c:300&quot;);//传参非常灵活 在send()函数进行传递参数 则可以在网络看到传递的参数 AJAX设置请求头信息1234//设置请求头xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);//也可以去自定义xhr.setRequestHeader(&#x27;name&#x27;,&#x27;atguigu&#x27;); 而server.js也需要做出更改 12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;);//创建应用对象const app = express();//创建路由规则// request是对响应报文的封装//response是对响应报文的封装app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX&#x27;);&#125;);//可以接收任意类型的请求app.all(&#x27;/server&#x27;,(request, response)=&gt;&#123; //all可以接收任意类型的请求 //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;); //加这一行代码 //设置响应体 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);//监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;) 不需要记住，会自动完成 经常利用setRequestHeader函数进行身份校验，传递给后端 Content-Type是来设置请求体内容的类型 application/x-www-form-urlencoded是给参数查询字符串的类型的固定写法","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"HTTP协议","slug":"HTTP协议","date":"2021-09-09T08:40:45.000Z","updated":"2021-09-09T11:45:59.602Z","comments":true,"path":"2021/09/09/HTTP协议/","link":"","permalink":"http://daniellin0516.github.io/2021/09/09/HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTPHTTP(hypertext transport protocol)协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则 请求报文重点是格式与参数： 行：POST /s?ie=utf–8 HTTP/1.1 头： HOST: atguigu.com Cookie: name=guigu Content-type: application/x-www-form-urlencoded User-Agent: chrome 83 空行： 体：username=admin&amp;password=admin 响应报文格式与参数： 行: HTTP/1.1 200（响应状态码，有404,403,401,500,200等） OK（响应状态字符串） 头: Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体: 123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"CSS方法写下拉菜单小三角","slug":"CSS方法写下拉菜单小三角","date":"2021-08-05T12:19:12.000Z","updated":"2021-08-05T12:46:11.447Z","comments":true,"path":"2021/08/05/CSS方法写下拉菜单小三角/","link":"","permalink":"http://daniellin0516.github.io/2021/08/05/CSS%E6%96%B9%E6%B3%95%E5%86%99%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E5%B0%8F%E4%B8%89%E8%A7%92/","excerpt":"","text":"小三角组成原理： 利用border给四个边框设置颜色如图所示： 若需要上箭头的话则要把border-top的属性设为none，左边和右边的属性设为transparent（透明色） 1234567.box1&#123; width: 0px; height: 0px; border: 20px solid transparent; border-top: none; border-bottom-color: tomato; &#125; 1234567891011121314li:hover &gt; .app::after&#123; content: &#x27;&#x27;; position: absolute; /*设置绝对定位使小三角上去*/ width: 0; height: 0; border: 8px solid transparent/*透明色*/; /*去除上边框*/ border-top: none ; border-bottom-color: white; bottom: 0; left: 0; /*使三角形居中*/ right: 0; margin: auto; &#125; 下拉菜单在有下拉菜单的父元素创建一个div块元素，根据需求调整大小，最重要的是display:none将模块隐藏，下面是小米二维码下拉菜单的一个例子： CSS 12345678910111213141516li:hover &gt; .app .qrcode &#123; display: block; &#125;/*设置app下载的下拉*/.app .qrcode&#123; display: none; position: absolute; /*开启绝对定位后不再占据位置*/ left: 22px; margin-left: -62px; width: 124px; height: 148px; background-color: white; line-height:1 ; text-align: center; box-shadow: 0 0 10px rgba(0, 0, 0, .3); HTML 12345678&lt;li&gt;&lt;a class=&quot;app&quot; href=&quot;ja:;&quot;&gt; 下载app &lt;!--添加一个弹出层--&gt; &lt;div class=&quot;qrcode&quot;&gt; &lt;img src=&quot;./img/download.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;小米商城app&lt;/span&gt; &lt;/div&gt; &lt;/a&gt;&lt;/li&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"背景和雪碧图","slug":"背景","date":"2021-08-02T09:18:10.000Z","updated":"2021-08-06T03:03:53.163Z","comments":true,"path":"2021/08/02/背景/","link":"","permalink":"http://daniellin0516.github.io/2021/08/02/%E8%83%8C%E6%99%AF/","excerpt":"","text":"背景background-image设置背景图片 1.可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色 2.如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满 3.如果背景的图片大于元素，将会一个部分背景无法显示 4.如果背景图片和元素一样大，则会直接正常显示 1background-image:url(); background-repeat 可选值： 1.repeat默认值，背景会沿着x轴，y轴双方向重复 2.repeat-x沿着x轴方向重复 3.repeat-y沿着y轴方向重复 4.no-repeat背景图片不重复 background-position用来设置背景图片的位置 设置方式： 1.通过 top left right bottom center 几个表示方位的词来设置背景图片位置 12background-position:center center ; //正中间background-position:top left ; //左上角 2.通过偏移量来指定背景图片的位置： 水平方向偏移量 垂直方向偏移量 1background-position:50px 50px; background-clip设置背景的范围 可选值： border-box默认值，背景会出现在边框的下边 padding-box 背景不会出现在边框，只出现在内容区和内边距 content-box背景只会出现在内容区 background-origin 背景图片的的偏移量计算的原点 padding-box默认值，background-position从内边距开始计算 content-box背景图片的偏移量从内容区计算 border-box背景图片的变量从边框开始计算 background-size 设置背景图片的大小 第一个值表示宽度 第二个值表示高度 如果只写一个，则第二个值默认是auto 1background-size：100% auto; 可选值： cover图片的比例不变，将元素铺满 contain图片比例不变，将图片在元素中完整显示 background-attachment背景图片是否跟随元素移动 可选值： scroll默认值，背景图片会跟随元素移动 fixed背景会固定在页面中，不会跟随元素移动 background背景图片的相关的简写属性，所有背景相关的样式都可以通过该样式来设置 并且该样式没有顺序要求，也没有哪个属性是必须写的 注意： background-size必须写在background-position后边，并且使用/隔开 1background-position/background-size background-origin background-clip两个样式，origin要在clip前边 超链接按钮的背景设置12345678910111213&lt;style&gt;a:link&#123; display:block; width:93px; height:29px; background-image:url();&#125;a:hover&#123; background-position:-93px 0;&#125;a:active&#123; background-position:-186px 0;&#125; 解决图片闪烁的问题： 可以将多个小图片同意保存到一个大图片中，然后通过调整background-position来显示，这样图片会同时加载到网页中，就可以有效的避免出现闪烁的问题，这个技术在网页中应用十分广泛，被称为CSS-Sprite，叫雪碧图 雪碧图使用步骤： 先确定要使用的图形 测量图标大小 根据测量结果创建一个元素 将雪碧图设置为元素的背景图片 设置一个偏移量以显示正确的图片 雪碧图特点： 一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户的体验 颜色的渐变线性渐变 background-image 线性渐变，颜色沿着一条直线发生变化 可选值： liner-gradient() 1background-image:liner-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区，线性渐变的开头，我们可以指定一个渐变的方向 to left to right to bottom to top xxxdeg（表示度数） turn表示圈 渐变可以同时制定多种颜色，多个颜色默认情况下平均分布，也可以手动指定简便的分布情况 1234567&lt;style&gt; .box1&#123; width: 200px; height: 220px; background-image: linear-gradient(to left,red 50px,yellow 100px); &#125;&lt;/style&gt; repeating-linear-gradient() 可以平铺的线性渐变 径向渐变 background-image: 可选值： radial-gradient 默认情况下径向渐变圆心的形状根据元素的形状来计算的： 正方形—&gt;圆形 长方形—-&gt;椭圆形 我们也可以手动指定径向渐变大小 circle ellipse 1234567&lt;style&gt; .box1&#123; width: 200px; height: 220px; background-image:radial-gradient(circle at center,red,yellow); &#125;&lt;/style&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"文本的水平和垂直对齐","slug":"文本的水平和垂直对齐","date":"2021-07-30T09:30:25.000Z","updated":"2021-07-30T09:59:53.762Z","comments":true,"path":"2021/07/30/文本的水平和垂直对齐/","link":"","permalink":"http://daniellin0516.github.io/2021/07/30/%E6%96%87%E6%9C%AC%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%AF%B9%E9%BD%90/","excerpt":"","text":"文本的水平对齐 text-align 可选值： left 左侧对齐 right 右侧对齐 bottom 底部对齐 middle 居中对齐 12345678&lt;style&gt; div&#123; width: 200px; border: 1px red solid; font-size: 50px; text-align: left; &#125;&lt;/style&gt; 设置元素垂直对齐的方式 vertical-align 可选值： baseline 默认值 基线对齐 top 顶部对齐 bottom 底部对齐 middle 居中对齐 其他文本样式文本修饰 text-decoration 可选值： none 什么都没有 underline 下划线 line-through 删除线 overline 上划线 1234.box1&#123; text-decoration:underline red; &#125; 文本显示 white-space 可选值： normal 正常 nowrap 不换行 pre 保留空白 12345678&lt;style&gt; .box1&#123; width: 100px; white-space: nowrap; overflow: hidden; /*超出宽度不显示*/ text-overflow:ellipsis; /*出现省略号*/ &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;今天天气真不错&lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"简单布局和高度塌陷以及BFC","slug":"简单布局和高度塌陷以及BFC","date":"2021-07-28T06:52:15.000Z","updated":"2021-07-29T06:54:03.456Z","comments":true,"path":"2021/07/28/简单布局和高度塌陷以及BFC/","link":"","permalink":"http://daniellin0516.github.io/2021/07/28/%E7%AE%80%E5%8D%95%E5%B8%83%E5%B1%80%E5%92%8C%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E4%BB%A5%E5%8F%8ABFC/","excerpt":"","text":"页面的简单布局123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; header,main,footer&#123; width: 1000px; margin: 0 auto; &#125; /*设置头部*/ header&#123; height:150px; background-color: silver; &#125; main&#123; height: 500px; background-color: #bfa; margin: 10px auto; &#125; nav&#123; width: 190px; height: 100%; background-color: yellow; float: left; &#125; article&#123; width: 600px; height: 100%; background-color: orange; float: left; margin:0 10px; &#125; aside&#123; width: 190px; height: 100%; background-color: pink; float: left; &#125; footer&#123; height: 150px; background-color: tomato; &#125;&lt;/style&gt; 下面是html基本写法： 123456789&lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt; 效果图： 高度塌陷1234567891011&lt;style&gt; .outer&#123; border: 10px red solid; &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; 123456&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 效果图： 里面的方块不随外面边框浮动，这就是高度塌陷 高度塌陷的问题： 在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失 父元素高度丢失后，其下的元素会自动上移，导致页面的布局混乱 所以高度塌陷是浮动布局中比较常见的一个问题，这个问题要处理 BFCBFC（Block Formatting Content）块级格式化环境 BFC是一个CSS中的一个隐含的属性，可以设为一个元素开启BFC 开启BFC该元素会变成一个独立的布局区域 元素开启BFC后的特点： 1.开启BFC的元素不会被浮动元素所覆盖 2.开启BFC的元素子元素和父元素外边距不会重叠 3.开始BFC的元素可以包含浮动的子元素 可以通过一些特殊方式来开启元素的BFC： 1.设置元素的浮动（不推荐）123456789101112&lt;style&gt; .outer&#123; border: 10px red solid; float:left /*添加浮动*/ &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; 副作用：宽度会丢失 2.将元素设置为行内块元素（不推荐）123456789101112&lt;style&gt; .outer&#123; border: 10px red solid; display:inline-block; &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; 3.将元素的overflow设置为一个非visible的值常用的方式，为元素试着overflow：hidden开启其BFC以使其可以包含浮动元素 123456789101112&lt;style&gt; .outer&#123; border: 10px red solid; overflow:hidden; &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; clear作用：清除浮动元素对当前元素产生的影响 可选值： left：清除左侧浮动元素对当前元素的影响 1234567891011121314.box1&#123; width:200px; height:200px; background-color:blue; font-size:50px; float: left;&#125;.box3&#123; width: 200px; height: 200px; background-color: purple; font-size: 50px; clear:left; /**清除box1浮动带来的影响，否则数字会环绕在box1旁边**/&#125; 用clear:left清除box1带来的浮动影响](https://imgtu.com/i/WHolRg) right：清除右侧浮动元素对当前元素的影响 123456789101112131415161718192021.box1&#123; width:200px; height:200px; background-color:blue; font-size:50px; float: left; &#125; .box2&#123; width: 400px; height: 400px; background-color: yellow; font-size: 50px; float:right; &#125; .box3&#123; width: 200px; height: 200px; background-color: purple; font-size: 50px; clear:right /**清除box2带来的浮动影响**/ &#125; both:清除两侧中最大影响的那侧 原理： 设置清除浮动以后，浏览器会自动为元素添加一个上外边距，以使其位置不受其他元素的影响 高度塌陷最终解决方法（最佳）运用伪元素::after 1234567891011121314151617&lt;style&gt; .box1&#123; border: 10px red solid; &#125; .box2&#123; width: 200px; height: 200px; background-color: #bfa; float: left; &#125; .box1::after&#123; content: &quot;&quot;; display: block; clear:both; &#125;&lt;/style&gt; 12345&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 会根据内容高度而改变 Clearfix（重要）这个样式可以同时解决高度塌陷和外边距重叠的问题，当你再遇到这些问题时，直接使用clearfix 1234567891011121314151617&lt;style&gt; .box1&#123; border: 10px red solid; &#125; .box2&#123; width: 200px; height: 200px; background-color: #bfa; float: left;&#125; .clearfix::before, .clearfix::after&#123; content: &quot;&quot;; display: table; clear: both; &#125;&lt;/style&gt; 123456&lt;body&gt; &lt;div class=&quot;box1 clearfix&quot; &gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"浮动","slug":"浮动","date":"2021-07-28T01:49:18.000Z","updated":"2021-07-29T01:40:59.967Z","comments":true,"path":"2021/07/28/浮动/","link":"","permalink":"http://daniellin0516.github.io/2021/07/28/%E6%B5%AE%E5%8A%A8/","excerpt":"","text":"浮动通过浮动可以使一个元素向其父元素的左侧或右侧移动 使float属性来设置于元素的浮动 可选值： none 默认值，元素不浮动 left 元素向左移动 right 元素向右移动 注意： 元素设置浮动以后，会完全从文档中脱离，不在占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动 浮动的特点 1.浮动元素会完全脱离文档流，不再占据文档流中的位置 2.设置浮动以后元素会向父元素的左侧或右侧移动 3.浮动元素默认不会从父元素中移除 4.浮动元素向左或向右移动时，不会超过它前边的其他浮动元素 5.如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移 6.浮动元素不会超过它上边的浮动兄弟元素，最多最多就是和它一样高 总结： 浮动目前来讲他的作妖作用时让页面水平排列，通过浮动可以制作一些水平方向的布局 1234567891011121314 &lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: #bfa; float:left; &#125; .box2&#123; width: 100px; height:100px; background-color: rgb(33, 16, 185); float: left; &#125;&lt;/style&gt; 12345&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/body&gt; 效果图： 浮动的特点 1.浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以利用浮动来设置文字环绕图片的效果 2.元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化： 脱离文档流的特点： 块元素： 1.块元素不在独占页面的一行 2.脱离文档流以后，块元素的宽度和高度默认都被内容撑开 行内元素： 1.行内元素脱离文档流以后会变成块元素，特点和块元素一样 脱离文档流以后，不需要再区分块和行内了","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"盒子模型","slug":"盒子模型","date":"2021-07-24T14:37:52.000Z","updated":"2021-07-29T01:40:47.289Z","comments":true,"path":"2021/07/24/盒子模型/","link":"","permalink":"http://daniellin0516.github.io/2021/07/24/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"盒子模型每一个盒子由以下部分组成：(一共盒子的可见框的大小由内容区，内边距，边框共同决定，所以在计算盒子大小时，需要将三个区域加到一块计算) 内容区（content）内容区大小由width和height属性设置 width：设置内容区的宽度 height：设置内容区的高度 内边距（padding） 内容区和边框之间的距离是内边距,，内边距设置会影响盒子大小 背景颜色会延申到内边距上 12345678&lt;style&gt;.box1&#123; width:200px; height:200px; background-color:green; border:10px orange solid; padding-top:200px;&#125; 一共有四个方向的内边距 padding-top padding-right padding-bottom padding left padding简写属性：可以同时指定四个方向的内边距，规则和border-width一样 1234padding:10px 20px 30px 40px;padding:10px 20px 30px;padding:10px 20px;padding:10px; 边框（border）边框属于盒子的边缘，边框里面属于盒子的内容，出了边框都是盒子的外部，边框的大小会影响到整个盒子的大小，要设置边框，需要至少设置三个样式： 边框的宽度：border-width 值的情况： 四个值（顺时针）：上 右 下 左（例如border width：10px 20px 30px 40px；） 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 除了border-width还有一组border-xxx-width xxx可以是top right bottom left 用来单独指定摸一个边的宽度 边框的颜色：border color 同样可以分别指定4个边框的颜色规则和border一样，默认值为黑色 边框的样式：border-style 指定边框样式，solid表示实线，dotted点状虚线，dashed虚线，double双线 border以及boder-xxx简写属性：10px solid orange；（无顺序要求） 外边距（margin）不会影响可见框的大小，会影响盒子所在位置 一共由四个方向的外边距： margin-top： 上外边距，设置一个正值，元素会向下移动 margin-right margin-bottom： 下外边距，设置一个正值，其下边的元素会向下移动 margin-left： 左外边距，设置一个正值，元素会向右移动 margin也可以设置负值，如果是负值则元素会向相反的方向移动 magin简写属性： margin可同时设置4个方向的外边距，用法和padding一样 margin会影响到盒子的实际占用空间 盒子模型-水平方向的布局元素的水平方向的布局： 元素在其父元素的水平方向的位置由以下几个属性共同决定： margin-left border-left padding-left width padding-right border-right margin-right 一个元素在其父元素中，水平布局必须要满足以下的等式： margin-left+border-left+padding-left+width+padding-right+border-right+margin-right=其父元素内容的宽度（必须满足） 调整情况： 1.如果这7个值中没有设为auto的情况，则浏览器会自动调整margin-right 这七个值中有三个值可以设置为auto： width margin-left margin-right 如果某个值为auto，则会自动调整为auto那个值以使等式成立 0+0+0+auto+0+0+0=800 auto=800 如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为aut0 如果将三个都设置为auto，则外边距都是0，宽度最大 如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值，所以我们经常利用这个特点来使一个元素在其父元素中水平居中 示例： 12width:xxxpx;margin:0 auto; 垂直方向的布局123456789101112&lt;style&gt; .box1&#123; width:200px; height:200px; background-color: chartreuse; &#125; .box2&#123; width: 100px; height:250px; background-color: coral; &#125; &lt;/style&gt; 1234&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 运行后结果： 子元素是在父元素的内容区中排列的： 如果子元素的大小超过了父元素，则子元素会从父元素中溢出使用overflow属性来设置父元素如何处理溢出的子元素 overflow可选值： visible：默认值，子元素会从父元素中溢出，在父元素外部的位置显示 hidden：溢出内容将会被裁剪不会显示 scroll：生成两个滚动条，通过滚动条来查看完整内容 auto：根据需要生成滚动条 12345678910111213&lt;style&gt; .box1&#123; width:200px; height:200px; background-color: chartreuse; overflow:hidden; /*在父元素下面写overlow*/ &#125; .box2&#123; width: 100px; height:250px; background-color: coral; &#125; &lt;/style&gt; overflow-x：处理水平方向溢出 overflow-y：处理竖直方向溢出 外边距的折叠相邻的垂直方向外边距会发生重叠现象 兄弟元素 兄弟元素间的相等垂直外边距会取两者之间的较大值（两者都是正值） 特殊情况： 如果相邻的外边距一正一负，则取两者的和 如果相邻的外边距都是负值，则取两者中绝对值较大的 兄弟元素之间的外边距重叠，对于开发使有利的，所以我们不需要进行处理 1234&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt; 父子元素 父子元素间相邻外边距，子元素的会传递给父元素（上外边距） 父子外边距的折叠会影响到页面的布局，必须要进行处理1.利用padding-top 123456&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 行内元素的盒模型行内元素不支持设置宽度和高度 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局 行内元素可以设置border，垂直方向的border不会影响页面的布局 行内元素可以设置margin，垂直方向的border不会影响页面的布局 display用来设置元素显示的类型： 可选值： inline：将元素设行内元素 block:将元素设置为块元素 inline-block：行内块元素（可放置宽高又不会独占一行） table：将元素设为一个表格 none:元素不在页面显示 visibility用来设置元素的显示状态： 可选值： 12345678910111213```hidden```：元素在页面隐藏，不显示，但是依然占据页面位置## 盒子的尺寸大小```css.box1&#123; width:100px; height:100px; backgroud-color:#bfa; padding:10px; border:10px red solid;&#125; 默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定（上述代码可见框140px） box-sizing：用来设置尺寸的计算方式（设置width和height的作用） 可选值： content-box：默认值，宽度和高度用来设置内容区的大小 border-box：宽度和高度用来设置整个盒子可见框的大小 ​ width和height指的是内容区和内边距和边框的大小 12345678.box1&#123; width:100px; height:100px; backgroud-color:#bfa; padding:10px; border:10px red solid; box-sizing:border-box&#125; 上述代码则为100px×100px的可见框大小，会自动缩小内容区的大小 轮廓阴影和圆角轮廓线outline：用来设置元素的轮廓线，用法和border一模一样 轮廓线不会影响到可见框的大小 123456.box1&#123; width:100px; height:100px; background-colorblue; outline:10px red solid;&#125; 123456.box1&#123; width:100px; height:100px; background-color:blue; border:10px red solid;&#125; ​ outline（左）和border（右）的区别 阴影box-shadow:用来设置元素的阴影效果，阴影不会影响页面的布局 第一个值：水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动 第二个值：垂直偏移量 设置阴影的垂直位置 正值向下移动 负值向上移动 第三个值：阴影的模糊半径，像素越大越模糊 第四个值：阴影的颜色 123456789&lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: blue; box-shadow:10px 10px 10px rgba(0, 0,0, 0.5); &#125; &lt;/style&gt; 效果图： 圆角border-radius：用来设置与圆角 border-top-left-radius: border-top-right-radius border-bottom-left-radius border-bottom-right-radius border-radius可以分别指定四个角的圆角 四个值：左上 右上 右下 坐下 三个值：左上 右上/左下 右下 两个值：左上/右下 右上/左下 将图形设置为圆形： 1border-radius:50%;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"选择器","slug":"选择器","date":"2021-07-22T10:32:01.000Z","updated":"2021-08-03T01:53:01.614Z","comments":true,"path":"2021/07/22/选择器/","link":"","permalink":"http://daniellin0516.github.io/2021/07/22/%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"常用选择器1.元素选择器123456p&#123; color=red;&#125;h1&#123; color=red;&#125; 2.id选择器根据id属性选中一个元素 12345&lt;style&gt;#red&#123; color:red;&#125;&lt;/style&gt; 12345&lt;body&gt; &lt;p id=&quot;red&quot;&gt; &lt;/p&gt;&lt;/body&gt; 3.class选择器class可重复，id不可重复 12345&lt;style&gt;.blue&#123; color:blue;&#125;&lt;/style&gt; 12345&lt;body&gt; &lt;p class=&quot;red&quot;&gt; &lt;/p&gt;&lt;/body&gt; 复合选择器1.交集选择器作用：选中同时复合多个条件的元素 语法：选择器1选择器2选择器3选择器n{} 注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头 1234567891011&lt;style&gt;.red&#123; color:red;&#125;div.red&#123; font-size:30px;&#125;.a.b.c&#123; color:blue;&#125;&lt;/style&gt; 1234567891011&lt;body&gt; &lt;div class=&quot;red&quot;&gt; 我是div &lt;/div&gt; &lt;p class=&quot;red&quot;&gt; 我是p &lt;/p&gt; &lt;div class=&quot;red2 a b c&quot;&gt; 我是div2 &lt;/div&gt;&lt;/body&gt; 下面是这段代码的图片： 选择器分组作用：同时选择多个选择器对应的元素 语法：选择器1，选择器2，选择器n{} 12345&lt;style&gt;h1,span&#123; color:green;&#125;&lt;/style&gt; 关系选择器 父元素：直接包含子元素的元素叫做父亲 子元素：直接被父元素包含的元素是子元素 祖先元素：直接或间接包含后代元素的元素叫做祖先元素 ​ 一个元素的父元素也是它的祖先元素 后代元素：直接或间接被祖先元素包含的元素叫做后代元素 ​ 子元素也是后代元素 兄弟元素：拥有相同父亲元素是兄弟元素 下面都是在这个html进行的例子： 12345678910&lt;body&gt; &lt;div&gt; 我是一个div &lt;p&gt; 我是div中的p元素 &lt;span&gt;我是p元素的span&lt;/span&gt; &lt;/p&gt; &lt;span&gt;我是div中的span元素&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; 1.子元素选择器作用：选定父元素的指定子元素 语法：父元素&gt;子元素（可用class选择元素） 例子：为div的子元素span设置一个字体颜色红色（为div直接包含的span设置一个字体红色） 12345&lt;style&gt;div&gt;span&#123; color:red;&#125;&lt;/style&gt; 2.后代选择器 作用：选中指令元素内的指定后代元素 语法：祖先 后代 12345&lt;style&gt;div span&#123; color:red;&#125;&lt;/style&gt; 3.兄弟选择器语法：前一个+子元素(找紧挨着的元素)（选择下一个兄弟） 12345&lt;style&gt;p+span&#123; color:red;&#125;&lt;/style&gt; 选择下面所有兄弟： 12345&lt;style&gt;p~span&#123; color:red;&#125;&lt;/style&gt; 属性选择器语法：[属性名]选择含有指定属性的元素 ​ [属性名=属性值]选择含有指定属性和属性值的元素 ​ [属性名^=属性值]选择属性值以指定值开头元素 ​ [属性名$=属性值]选择属性值以指定值结尾元素 ​ [属性名*=属性值]选择属性值中含有某值的元素 12345&lt;style&gt;p[title=abc]&#123; color:red;&#125;&lt;/style&gt; 12345&lt;body&gt; &lt;p title=&quot;abc&quot;&gt; 1111 &lt;/p&gt;&lt;/body&gt; 伪类选择器伪类用来描述一个元素的特殊状态 比如：第一个元素、被点击的元素，鼠标移入的元素 伪类一般：开头 1.:first-child第一个子元素 12345&lt;style&gt;ul&gt;li:first-child&#123; color:red;&#125;&lt;/style&gt; 123456789&lt;body&gt; &lt;ul&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 2.:last-child最后一个子元素 3.nth-child(n)选中第n个子元素 nth-child(2)选第二个子元素 特殊值： n 第n个 n的范围：0到正无穷 2n（even） 偶数位元素 2n+1（odd）奇数位元素 4.:first-of-type :last -of-type :nth-of-type这几个伪类的功能和上述的类似，不通点是他们是在同类型中进行排序 12345&lt;style&gt;ul&gt;li:first-of-type&#123; color:red;&#125;&lt;/style&gt; 12345678910&lt;body&gt; &lt;ul&gt; &lt;span&gt;11&lt;/span&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 5.:not()否定伪类，将符合条件元素从选择器去除 12345&lt;style&gt;ul&gt;li:not(:nth-child(3))&#123; color:red;&#125;&lt;/style&gt; 将第三个子元素去除掉，其他全为红色 超链接伪类1.:link用来表示没访问过的链接（正常的链接） 2.:visited用来表示访问过的链接 3.:hover表示鼠标移入状态 4.：active表示鼠标点击 伪元素选择器伪元素通常使用::开头 1.::first-letter表示第一个字母 12345&lt;style&gt;p::first-letter&#123; font-size:90px;&#125;&lt;/style&gt; 会使文本第一个字母放大 2.::first-line表示第一行 3.::selection表示选中的内容（需要鼠标拖动） 4.::before元素的开始的位置，必须结合content属性使用 12345&lt;style&gt;div::before&#123; content:&#x27;abc&#x27;; color:red;&#125; 12345&lt;body&gt; &lt;div&gt; hello &lt;/div&gt;&lt;/body&gt; 5.::after元素的最后的位置，必须结合content属性使用","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"CSS修改元素样式和语法","slug":"CSS修改元素样式和语法","date":"2021-07-22T05:58:02.000Z","updated":"2021-07-29T01:41:58.094Z","comments":true,"path":"2021/07/22/CSS修改元素样式和语法/","link":"","permalink":"http://daniellin0516.github.io/2021/07/22/CSS%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%92%8C%E8%AF%AD%E6%B3%95/","excerpt":"","text":"使用css修改元素样式1.第一种 内联样式，行内样式（不推荐使用，只能对一个标签生效） 在标签内部通过style属性设置元素样式 1&lt;p style=&quot;color:red font-size:20px&quot;&gt;&lt;/p&gt; 2.第二种 内部样式表（方便更改，使用，只能对一个网页作用） 1234567&lt;head&gt;&lt;style&gt;p&#123; color:&quot;green&quot;&#125;&lt;/style&gt;&lt;/head&gt; 3.第三种 外部样式表（加快网页加载速度，提高用户体验） 将css样式编写到一个外部的CSS文件中 通过link标签引入外部css文件 CSS语法 基本语法：选择器 声明块 选择器：可选中页面指定元素，比如p作用就是选中页面所有p元素 声明块：通过声明块来指定为元素设置样式","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"HTML","slug":"HTML-1","date":"2021-07-20T06:00:51.000Z","updated":"2021-08-17T02:15:46.582Z","comments":true,"path":"2021/07/20/HTML-1/","link":"","permalink":"http://daniellin0516.github.io/2021/07/20/HTML-1/","excerpt":"","text":"网页结构W3C标准 结构：HTML用于描述页面结构 表现：CSS用于控制页面中元素的样式 行为：JavaScript用于响应用户操作 HTML结构123456789101112&lt;!DOCTYPE html&gt; &lt;!--html5的文档声明--&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; HTML实体的语法1.&amp;nbsp;表示一个空格 2.gt;表示一个大于号 3.lt;表示一个小于号 4.copy;表示版权符号 标签1.meta标签属性： name：指定的数据名称（关键词） http-equiv:将页面重定向到另一个网站 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=http://baidu.com&quot;&gt; 过三秒后会定向到百度页面 content:指定的数据内容 keywords 1&lt;meta name=&quot;keywords&quot; content=&quot;购物&quot;&gt; 在搜索引擎搜索购物即可搜到该页面 description 1&lt;meta name=&quot;description&quot; content=&quot;****&quot;&gt; 用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中，如图所示： 2.语义化标签2-1标题标签 h标签（块元素） 123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 从h1到h6重要性递减，h1最重要，h6最不重要 p标签（块元素） 1&lt;p&gt;在p标签内容表示一个段落&lt;/p&gt; hgrourp标签 12345678&lt;hgroup&gt; &lt;h1&gt; 回乡偶书 &lt;/h1&gt; &lt;h2&gt; 其一 &lt;/h2&gt;&lt;/hgroup&gt; 用来为标题分组，可以将一组相关标题同时放入hgroup里 em标签（行内元素） 1&lt;p&gt;今天&lt;em&gt;天气&lt;/em&gt;真好&lt;/p&gt; 表示语音语调的一个加重 strong标签（行内元素） 加粗字体，强调 blockquote标签（块元素） 长引用，通常用来表达名人名言 q标签（行内元素） 短引用，表达名人名言不会换行 br标签（块元素） 换行用，独占一行 2-2布局标签1&lt;header&gt;：表示网页头部2.&lt;main&gt;:表示网页的主题部分（一个页面只有一个）3.&lt;footer&gt;:表示网页底部4.&lt;nav&gt;:表示网页的导航5.&lt;aside&gt;:和主体相关其他内容（侧边栏） 6.&lt;article&gt; ：独立文章 7.&lt;section&gt;:表示一个独立区块，上边的标签都不能使用section 8.&lt;div&gt;:没语义，用来表示一个区块，div还是主要布局元素，块元素 9.&lt;span&gt;:行内元素，没有任何语义，一般用于在网页中选中文字 2-3列表标签一.分类1.无序列表使用ul标签创建有序列表，使用li表示列表项 1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 2.有序列表使用ol标签创建有序列表，使用li表示列表项 1234&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 3.定义列表使用dl标签创建有序列表，使用dt表示列表项 二.嵌套12345678&lt;ul&gt; &lt;li&gt;aa &lt;ul&gt; &lt;li&gt;aa-1&lt;/li&gt; &lt;li&gt;aa-2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 如下图所示： 2-4超链接 &lt;a&gt;&lt;/a&gt;(行内元素) 属性： href:目标路径 1&lt;a href=&quot;https：//www.baidu.com&quot;&gt;超链接&lt;/a&gt; 相对路径都会使用.或..开头 ./表示当前文件所在目录 .//表示当前文件所在目录的上一级目录 targrt：用来指定超链接打开位置 可选值：_self 默认值，在当前页面打开超链接 ​ _blank 在一个新的页面打开超链接 1&lt;a href=&quot;https：//www.baidu.com&quot; target=&quot;_blank&quot;&gt;超链接&lt;/a&gt; id：可以跳转到页面指定位置，只需将href属性设置#目标关系，id唯一不重复 1&lt;a id=&quot;bottom&quot; href=&quot;#&quot;&gt;最底部&lt;/a&gt; ==另：== 1&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; 用JavaScript作为href属性，点击超链接不会发生 2-5图片标签 img标签（自结束标签） src属性：指定外部图片路径（路径规则和超链接是一样的） 1&lt;img src=&quot;&quot;&gt; alt属性：图片描述，描述默认不会显示，无法加载的时候显示，类似关键词 width属性：图片宽度（单位是像素） heigh属性：图片高度 2-6内联框架 iframe标签 src属性：指定引入网页的路径 frameborder：指定内联框架边框 2-7音视频1.音频 audio标签 属性： controls:是否允许用户控制播放 autoplay：音频文件是否自动播放 loop：循环 1&lt;audio src=&quot;***.mp3 contrlos autoplay&quot;&gt;&lt;/audio&gt; 2.视频 vedio标签 使用方式和audio一样 form标签 提交框： 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/form&gt; 文本框： 注意：数据要提交到服务器中，必须为元素设定一个name属性值 123&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/form&gt; 密码框： 123&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;username&quot;&gt;&lt;/form&gt; 单选按钮 1234&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;b&quot; checked&gt;&lt;/form&gt; 多选按钮 1234&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;username&quot; value=&quot;1&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;username&quot; value=&quot;2&quot; checked&gt;&lt;/form&gt; 下拉列表 1234567&lt;form&gt; &lt;select name=&quot;haha&quot;&gt; &lt;option value=&quot;1&quot;&gt;选项一&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;选项二&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;选项三&lt;/option&gt; &lt;/select&gt;&lt;/form&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"Markdown基本用法","slug":"Markdown基本用法","date":"2021-07-20T01:06:45.000Z","updated":"2021-07-29T01:41:12.719Z","comments":true,"path":"2021/07/20/Markdown基本用法/","link":"","permalink":"http://daniellin0516.github.io/2021/07/20/Markdown%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"","text":"代码块1```+语言(java) 标题1234561.# 一级标题2.## 二级标题3.### 三级标题4.#### 四级标题5.##### 五级标题6.###### 六级标题 字体123456781.加粗 **内容**2.代码高亮显示`内容`3.删除线~~内容~~4.斜体*内容* 1.加粗内容2.代码高亮显示内容 3.删除线内容4.斜体内容 引用123&gt;内容&gt;&gt;内容&gt;&gt;&gt;内容 内容 内容 内容 分割线12--- //分割线1*** //分割线2 图片插入在线图片/本地图片 1![我的照片](照片链接) 列表无序列表 123- 目录一- 目录二- 目录三 目录一 目录二 目录三 有序列表 1231. 名称2. 名称3. 名称 名称 名称 名称 表格鼠标右键： 插入表格即可","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://daniellin0516.github.io/tags/Markdown/"}]},{"title":"Github+Hexo搭建个人博客","slug":"HTML","date":"2021-07-18T10:34:52.000Z","updated":"2021-07-29T01:41:37.745Z","comments":true,"path":"2021/07/18/HTML/","link":"","permalink":"http://daniellin0516.github.io/2021/07/18/HTML/","excerpt":"","text":"准备工作 (Node.js (nodejs.org))下载nodejs LTS版本 (Git - Downloads (git-scm.com))下载git 第一步 win+R启动，以管理员身份运行（windows系统自动会切到root用户） 在命令行输入： 1npm install -g cnpm --registry=https://registry.npm.taobao.org ​ 下载淘宝镜像源，稍等几秒 安装hexo框架，在命令行输入： 12cnpm install -g hexo-cli//安装完成之后可以输入hexo -v看版本 查看文件夹，并在该文件夹创建blog文件夹，进入blog文件夹 1234pwd //查看文件夹mkdir blog //创建文件夹cd blog/ //进入文件夹pwd //查看下路径对不对 用hexo生成博客 1hexo init 启动博客 1hexo s //进入本端给的地址 将我们自己的博客部署到github上公开使用 进入github之后，点击右上角 注意 例如我的是：DanielLin0516.github.io 在blog目录下安装一个git部署的插件 在命令行输入： 12pwd //查看路径cnpm install --save hexo-deployer-git 去设置_config.yml文件 1notepad _config.yml //用记事本去改Deoloyment里面的东西 type: git（注意前面要空一格） repo: （复制自己github上面的地址，前面空一格） branch： master 保存后退出即可 部署到远端 1hexo d 输入账号密码即可 这时刷新gitub仓库会多了很多内容 这样就成功部署到github上面了！！ 更改主题 去github去找主题 将git clone内串代码复制到命令行进行下载主题，会下载到theme这个文件夹里 在命令行输入： 1notepad _config.yml ​ 去更改记事本里面的theme：***即可 在本端进行查看，若可以的话直接上传到github上面123hexo ghexo shexo d","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://daniellin0516.github.io/tags/Blog/"}]}],"categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"},{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"},{"name":"Markdown","slug":"Markdown","permalink":"http://daniellin0516.github.io/tags/Markdown/"},{"name":"Blog","slug":"Blog","permalink":"http://daniellin0516.github.io/tags/Blog/"}]}