{"meta":{"title":"Daniel Blog","subtitle":"","description":"It is the new beginning of coding!","author":"Daniel Lin","url":"http://daniellin0516.github.io","root":"/"},"pages":[{"title":"about","date":"2021-07-18T16:56:43.000Z","updated":"2021-07-19T01:55:22.431Z","comments":false,"path":"about/index.html","permalink":"http://daniellin0516.github.io/about/index.html","excerpt":"","text":"本人刚接触编程~现在为大连理工大学的一名大三学生 12345678public Class Coding&#123; public static void main() &#123; System.out.println(&quot;Start Coding……&quot;) &#125;&#125;"},{"title":"categories","date":"2021-07-18T16:16:50.000Z","updated":"2021-07-18T16:45:04.989Z","comments":true,"path":"categories/index.html","permalink":"http://daniellin0516.github.io/categories/index.html","excerpt":"","text":""},{"title":"repositories","date":"2021-07-18T16:51:19.962Z","updated":"2021-07-18T16:51:19.962Z","comments":false,"path":"repository/index.html","permalink":"http://daniellin0516.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-18T16:21:13.000Z","updated":"2021-07-18T16:43:55.282Z","comments":false,"path":"tags/index.html","permalink":"http://daniellin0516.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"diff算法","slug":"diff算法","date":"2022-02-14T14:34:38.000Z","updated":"2022-02-14T15:24:10.036Z","comments":true,"path":"2022/02/14/diff算法/","link":"","permalink":"http://daniellin0516.github.io/2022/02/14/diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"diff新老节点替换的规则 如果新老节点不是同一个节点名称，那么就暴力删除旧的节点，创建插入新的节点 只能同级比较、不能跨层比较。如果跨层那么就暴力删除旧的节点，创建插入新的节点 如果是相同节点，又分为很多种情况： 新节点没有children ​ 如果新的节点没有children，那就证明新节点是文本，那直接把旧的节点替换成新的文本 新节点有children，旧的没有：则创建元素添加（把旧的内容删除清空掉，增加新的） 新的节点有children，旧的也有children（diff算法核心）下面进行细讲 diff算法核心新的节点有children，旧的节点也有children 1.旧前 和 新前 匹配的话：旧前指针++ 新前的指针++ 2.旧后 和 新后 匹配的话：旧后的指针– 新后的指针– 3.旧前 和 新后 匹配的话：旧前的指针++ 新后的指针– 4.旧后 和 新前 匹配的话：旧后的指针– 新前的指针++ 5.以上都不满足条件（查找） 新的指针++ 新的添加到页面上并且旧的中有，要给旧的赋值成undefined 6.创建或者删除","categories":[],"tags":[{"name":"项目总结分析","slug":"项目总结分析","permalink":"http://daniellin0516.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"}]},{"title":"手写Promise","slug":"手写Promise","date":"2022-01-04T15:30:05.000Z","updated":"2022-01-07T16:46:57.578Z","comments":true,"path":"2022/01/04/手写Promise/","link":"","permalink":"http://daniellin0516.github.io/2022/01/04/%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"一步一步教你手写Promise 写这篇文章主要目的是为了巩固自己的知识点以及更深入了解promise的原理，对于初学者有一些不友好，建议初学者先去了解promise基本用法再来看这篇文章。从零开始一步一步教学写then、all、catch、race、Promise.resolve、Promise.reject，原理的话一边写一边给大家介绍，那我们就开始吧！ 第一步：初始结构搭建 我们都知道Promise总共有三种状态，分别是pending、fulfilled、reject，三种状态不可逆，通过调用resolve、reject以及抛出错误可以改变状态，只能是pending–&gt;fulfilled或者是pending–&gt;reject，我们throw利用try catch去捕捉错误信息 123456789101112131415161718192021222324252627282930313233343536function Promise(executor)&#123; //添加属性，一开始的状态为pending this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; //保存实例对象的this值 const self = this; //resolve 函数 function resolve(data)&#123; // 判断状态（解决状态可逆）若状态不为pending下面代码则无法执行直接return if(self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;fulfilled&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; &#125; //reject 函数 function reject(data)&#123; // 判断状态（解决状态可逆）若状态不为pending下面代码则无法执行直接return if(self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;rejectd&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; &#125; try&#123; //同步调用执行器函数,执行resolve和reject executor(resolve,reject); &#125;catch(e)&#123; //若抛出错误的话则会变成reject状态 reject(e); &#125;&#125;//给原型添加then方法，这样实例对象可以用then方法Promise.prototype.then = function(onResolved,onRejected)&#123; &#125; 这样一开始的结构差不多就搭建完啦，自己可以去验证一下 第二步：then方法1.then方法执行回调Promise.then要传两个回调函数，一个是当状态为fulfilled的回调函数另一个则为状态为reject状态的回调函数 12345678Promise.prototype.then = function (onResolved, onRejected) &#123; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; onResolved(this.PromiseResult); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125;&#125; 得到的结果如下图所示： 当然这还不是最终版我们还会进行完善，请继续往下看 2.异步任务回调的执行现在假如有一个场景需要有异步任务回调执行，过几秒才会变状态，这怎么执行呢，所以我们要继续完善我们的代码，使其可以异步任务回调的执行,若在我们刚刚写的代码加入异步任务回调会怎么样呢？ 12345678910let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;123&#x27;); &#125;, 1000)&#125;)p.then(value =&gt; &#123; console.log(value);&#125;, reason =&gt; &#123; console.warn(reason);&#125;) 答案是：没有输出，没有执行。经过一秒才会去改变状态，所以进入then回调函数的时候他的一开始状态是处于pending状态而我们的代码没有去判断这个状态的函数。 1.所以我们要去完善并判断当一开始状态是pending的情况。 2.当我们状态还是pending状态时候,我们怎么实现当状态发生改变的时候去执行回调函数呢，状态未发生变化则不能执行回调函数，等状态改变再去调用保存的回调函数， 这时候就用的有点巧妙了，先将回调函数进行保存，我们新建一个callback属性用来保存回调函数（+++号表示新增代码） 3.4.回调函数保存后，我们该什么时候去调用它呢，我们需要状态改变后去调用onResolved、onRejected函数，则我们找到resolve,reject进行编写,我们去判断callback里面是否有回调函数，如果有的话则在状态之后调用函数 1234567891011121314151617181920212223242526272829303132333435363738394041function Promise(executor) &#123; //添加属性，一开始的状态为pending this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; // 声明属性保存回调函数 this.callback = &#123;&#125;; //2.++++++++++++++++ //保存实例对象的this值 const self = this; //resolve 函数 function resolve(data) &#123; // 判断状态（解决状态可逆） if (self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;fulfilled&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; //调用成功的回调函数 3.++++++++++++ if(self.callback.onResolved)&#123; self.callback.onResolved(); &#125; &#125; //reject 函数 function reject(data) &#123; // 判断状态（解决状态可逆） if (self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;rejected&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; //调用失败的回调函数 4.++++++++ if(self.callback.onRejected)&#123; self.callback.onRejected(); &#125; &#125; try &#123; //同步调用执行器函数,执行resolve和reject executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125; 当然我们的then方法也得进行更新 123456789101112131415161718Promise.prototype.then = function (onResolved, onRejected) &#123; //成功状态 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; onResolved(this.PromiseResult); &#125; //失败状态 if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125; //异步状态处理 if(this.PromiseState === &#x27;pending&#x27;)&#123; //1.++++++++++ //保存回调函数 this.callback = &#123; onResolved, //键值和键名相等简写 onRejected &#125; &#125; //+++++++&#125; 现在打印p进行查看则有callback属性（回调函数） 现在我们的then方法就可以异步任务回调的执行啦，将上面setTimeout内行代码执行在控制台进行查看，过一秒输出结果，如下图所示 ==注意！！== 我们等一秒输出结果之后再点开promise对象状态会变成fulfilled，若还未输出结果就点开promise对象则状态还是pending 3.指定多个回调函数 当我们执行下列代码会发生什么呢 12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;123&#x27;); &#125;, 1000);&#125;)p.then(value =&gt; &#123; console.log(value);&#125;, reason =&gt; &#123; console.warn(reason);&#125;)p.then(value =&gt; &#123; alert(value);&#125;, reason =&gt; &#123; alert(reason);&#125;)console.log(p) 用内置的Promise则会先输出123然后再弹出一个alert 123的弹窗，而用我们刚刚自己写的Promise会发生什么呢？答案是只会弹出一个alert 123弹窗，为什么会这样子呢？因为后面的回调函数覆盖了前面console.log的回调所以只有一个弹窗输出，所以我们还要进行代码改进 1。对于回调函数的保存我们要进行改变，声明一个callbacks数组保存回调函数，上一步我们用的是对象进行保存。 2.然后将每个回调函数作为对象push到callbacks这个数组里面 3.此时数组存放多个对象，每个对象则有onResolved,onRejected回调函数，利用forEach遍历数组执行回调函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Promise(executor) &#123; //添加属性，一开始的状态为pending this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; // 声明属性（改用数组的方法） 1.+++++++++ this.callbacks= []; //保存实例对象的this值 const self = this; //resolve 函数 function resolve(data) &#123; // 判断状态（解决状态可逆） if (self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;fulfilled&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; //调用成功的回调函数 3.+++++++ self.callbacks.forEach(item =&gt; &#123; item.onResolved(data) &#125;) &#125; //reject 函数 function reject(data) &#123; // 判断状态（解决状态可逆） if (self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;rejected&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; //调用失败的回调函数 self.callbacks.forEach(item =&gt; &#123; //4.++++++++ item.onRejected(data) &#125;) &#125; try &#123; //同步调用执行器函数,执行resolve和reject executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;//给原型添加then方法，这样实例对象可以用then方法Promise.prototype.then = function (onResolved, onRejected) &#123; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; onResolved(this.PromiseResult); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125; if(this.PromiseState === &#x27;pending&#x27;)&#123; this.callbacks.push(&#123; // 2.+++++++ onResolved, onRejected &#125;) &#125;&#125; 这样我们就又完成了一个小点，将上述代码运行可得下列结果 4.同步修改状态then方法结果返回 我们都知道调用then后返回的对象是一个promise对象，我们用内置的Promise来执行一下下面的结果 123456789let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;ok&#x27;);&#125;)const result = p.then(value =&gt; &#123; console.log(value);&#125;,reason =&gt; &#123; console.log(reason)&#125;)console.log(result) 结果如下图所示： 用我们上面自己写的Promise则不会返回一个Promise对象，我们继续再来改写一下 1.我们在then方法里面套一个Promise，确保then返回的是一个Promise对象 2.首先我们要明白如果在then里面没有一个返回值也就是没有return，它返回的是一个成功的Promise对象，若then里面又return一个Promise对象则是看里面的Promise是什么状态返回的对象就是什么状态，当我们处于成功状态的时候会执行onResolved回调，失败则会调用onRejected回调 3.首先判断then里面onResolved回调返回的是一个Promise对象的话，则我们可以运行.then方法获取结果，若返回的不是一个Promise的话，则直接去调用resolve方法使状态变为成功 4.若我们在then回调里抛出一个错误，则返回的对象也是一个失败的状态，跟上面捕捉错误方法一样去利用try catch 1234567891011121314151617181920212223242526272829303132333435Promise.prototype.then = function (onResolved, onRejected) &#123; return new Promise((resolve, reject) =&gt; &#123; //1.++++++++ if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; try &#123; //4.++++++++ // 获取回调函数的执行结果 let result = onResolved(this.PromiseResult); //判断 if (result instanceof Promise) &#123; //2.+++++++ //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; // 3.+++++++ //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; //若检测到有抛出错误时则变为失败的状态 reject(e); &#125; &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125; if (this.PromiseState === &#x27;pending&#x27;) &#123; this.callbacks.push(&#123; onResolved, onRejected &#125;) &#125; &#125;)&#125; ==我们用我们写的Promise运行下面代码== 1234567891011121314151617181920212223242526272829303132//当then里面回调返回是一个Promiselet p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;ok&#x27;);&#125;)const res = p.then(value =&gt; &#123; return new Promise((resolve,reject) =&gt; &#123; resolve(&#x27;123333&#x27;); &#125;)&#125;,reason =&gt; &#123; console.log(reason);&#125;)console.log(res);//当then里面回调返回不是一个Promise(无return)let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;ok&#x27;);&#125;)const res1 = p1.then(value =&gt; &#123; console.log(value)&#125;,reason =&gt; &#123; console.log(reason);&#125;)console.log(res1);//当then里面抛出一个错误let p2 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;ok&#x27;);&#125;)const res2 = p2.then(value =&gt; &#123; throw &#x27;error&#x27;;&#125;,reason =&gt; &#123; console.log(reason);&#125;)console.log(res2); 运行结果如下图所示： 5.异步修改状态then方法结果返回 有人问这步骤刚刚2.2不是已经做过了嘛？答案是：不一样 执行下列代码就知道了 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok&#x27;); &#125;, 1000);&#125;)const res = p.then(value =&gt; &#123; console.log(value)&#125;,reason =&gt; &#123; console.log(reason);&#125;)console.log(res); 这时候’ok’会经过一秒输出，但是res状态还是处于pending状态并没有发生改变，这是为什么呢？我们在.then方法里面执行回调函数，而我们要根据回调函数去返回res的一个状态，这个意思就是若我们执行onResolved回调的时候我们状态就是成功的并且要返回给Promise对象也是成功的(res)。 1.我们之前在this.PromiseState === ‘pending’时候去直接调用回调这是不可行的，我们稍微做改进变为一个函数,并且把PromiseResult参数传入 2.接下来几步都是和上面一样进行判断啦，判断返回的是否是一个Promise对象，这里就不再重复诉说了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; return new Promise((resolve, reject) =&gt; &#123; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; try &#123; // 获取回调函数的执行结果 let result = onResolved(this.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125; if (this.PromiseState === &#x27;pending&#x27;) &#123; this.callbacks.push(&#123; onResolved: function () &#123; //1.++++++++ try &#123; //2.下面和上面内个步骤一样具体可以去看2.4+++++++++++ //执行成功回调函数 let result = onResolved(self.PromiseResult); // 判断 if (result instanceof Promise) &#123; result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;, onRejected: function () &#123; //1.++++++++ try &#123; //2.++++++++ onRejected(self.PromiseResult); let result = onRejected(self.PromiseResult); // 判断 if (result instanceof Promise) &#123; result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; &#125;) &#125; &#125;)&#125; 然后我们在运行上面的示范例子的代码可以得到正确的结果，如下图所示： 6.then方法完善和优化 由我们上述图片可知，我们还未对状态为失败的时候进行改进，所以我们也对失败状态进行更改，详细步骤请见2.4，若不改进的话若Promise里面调用reject()，则状态还会处于pending状态而不是fulfilled状态 12345678910111213141516if (this.PromiseState === &#x27;rejected&#x27;) &#123;try &#123; let result = onRejected(this.PromiseResult); if(result instanceof Promise)&#123; result.then(v =&gt; &#123; resolve(v); &#125;,r =&gt; &#123; reject(r); &#125;) &#125;else&#123; resolve(result); &#125;&#125; catch (e) &#123; reject(e);&#125;&#125; 细心的小伙伴有没有发现上面这行代码已经复用很多次啦？我们可以封装一个函数去使代码更加的简洁以及维护的更加方便 123456789101112131415161718192021//封装函数function callback(type) &#123; try &#123; // 获取回调函数的执行结果 let result = type(this.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125;&#125; 接下里贴一下我们then方法已经变得非常简洁明了啦 12345678910111213141516171819202122232425262728293031323334353637383940414243Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; return new Promise((resolve, reject) =&gt; &#123; //封装函数 function callback(type) &#123; try &#123; // 获取回调函数的执行结果 let result = type(self.PromiseResult); //注意这里面的this指向哦！！记得要更改 //判断 if (result instanceof Promise) &#123; //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); &#125; if (this.PromiseState === &#x27;pending&#x27;) &#123; this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;) &#125; &#125;)&#125; !!这样我们的then方法就已经完成啦！！有没有坚持到这里的小伙伴嘛在评论区call个1 第三步：catch方法 接下来我们来封装catch方法，catch方法用来指定失败的回调函数，并且返回结果也是一个Promise对象,这时候我们就可以用到我们已经封装好的then方法 1234//添加catch方法Promise.prototype.catch = function(onRejected)&#123; return this.then(undefined, onRejected)；&#125; 接下来我们执行这行代码: 123456789101112131415let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;error&#x27;) &#125;, 1000);&#125;)p.then(value =&gt; &#123; console.log(111);&#125;).then(value =&gt; &#123; console.log(222);&#125;).then(value =&gt; &#123; console.log(333);&#125;).catch(reason =&gt; &#123; console.log(reason);&#125;) 如果你对Promise有了解的话应该知道上面的代码应该会输出error，没错这个就是catch方法的异常穿透，若其中有一部分发生错误的话，则catch会立马接收到这个信息，利用我们上述刚刚写的catch方法会报错，这是为什么呢？ 答案是：当我们p对象还是pending状态的时候会去进行回调函数的保存，console.log(111)这个回调函数返回的是一个pending状态的Promise，且这个回调函数会保存在p这个对象属性上面而且这个失败的回调是一个undefined：因为第二个参数并没有传，状态改完之后会执行reject()函数，则会报错，最简单的来讲失败的原因是因为第二个参数没有传入 1.当然我们内置的Promise.then里面是可以少传参数的，所以我们要进行判断then方法回调函数是否有onRejected参数传入 2.我们同样也要对onResolved函数是否传入进行判断，若没有进行判断的话，则就无法进行then方法的值的传递，所以我们同样的也要用同样的方法进行判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; // 判断回调函数参数 if (typeof onRejected !== &#x27;function&#x27;) &#123; //1.+++++++++++ onRejected = reason =&gt; &#123; throw reason; &#125; &#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; //2.++++++++++ onResolved = value =&gt; value; //value =&gt; &#123;return value&#125; &#125; return new Promise((resolve, reject) =&gt; &#123; //封装函数 function callback(type) &#123; try &#123; // 获取回调函数的执行结果 let result = type(self.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); &#125; if (this.PromiseState === &#x27;pending&#x27;) &#123; this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;) &#125; &#125;)&#125; 用我们写好的catch方法去执行下来代码的结果为： 1234567891011121314let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;okok&#x27;); &#125;, 1000);&#125;)p.then().then(value =&gt; &#123; console.log(222); throw &#x27;error&#x27;;&#125;).then(value =&gt; &#123; console.log(333);&#125;).catch(reason =&gt; &#123; console.warn(reason);&#125;) !!这样我们的catch方法就完成啦！！是不是很简单(没有啦还挺绕的自己重新再写一遍还是有点困难) 第四步：resolve方法封装 我们的resolve方法不属于实例对象上面的方法，而是属于Promise这个函数对象的方法，所以我们添加应该下面这样声明,并且传递value参数，返回一个Promise对象 这里我们也要再次判断传入的这个参数是否是一个Promise对象，如果是的话则可以直接调用then方法，不是的话则返回一个Promise对象给它 123456789101112131415Promise.resolve = function(value)&#123; // 返回Promise对象 return new Promise((resolve,reject) =&gt; &#123; if(value instanceof Promise)&#123; value.then(v =&gt; &#123; resolve(v); &#125;,r =&gt; &#123; reject(r); &#125;) &#125; else&#123; //状态设置为成功 resolve(value); &#125; &#125;);&#125; 执行下列代码进行演示： 123456let p = Promise.resolve(&#x27;ok&#x27;);const p2 = Promise.resolve(new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;success&#x27;);&#125;));console.log(p);console.log(p2); 结果为： !!这样我们的resolve方法就完成啦！！ 第五步：reject方法封装这个方法和resolve相似这里就不再进一步解释啦 123456//添加reject方法Promise.reject = function (reason) &#123; return new Promise((resolve,reject) =&gt; &#123; reject(reason); &#125;);&#125; 第六步：all方法封装 我们all方法，返回的结果是一个Promise对象，参数通常是传入一个数组，结果由promise这个的数组状态决定，若数组里面的Promise都成功则返回结果是一个成功的状态，以及数组的一个结果，若其中一个失败的话，返回的结果是一个Promise失败的对象且返回的是数组里面失败的Promise的结果 1234567let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;Ok&#x27;);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 =Promise.resolve(&#x27;123&#x27;);let result = Promise.all([p1,p2,p3]);console.log(result) 下列为内置Promise的结果： 返回结果的状态是根据数组里面的Promise去判断的 如何判断都成功呢？ 1.所以我们要用到遍历，去遍历传进来的这个数组promises,并且每个对象都可以调用then方法 2.我们需要遍历完数组去判断是否都为成功，遍历完数组才能去调用resolve函数，而不是遍历完一个promise[i]就去调用，这样子的话假如第一个成功的话就直接返回了。所以我们需要声明一个变量去计算成功的个数，并且成功状态加1，等遍历完数组进行一个判断：如果这个count的值与传进来的数组长度一样，则代表所有的promise都为成功，再去调用resolve函数返回一个成功的对象 3.我们all方法调用完需要有一个数组去保存结果，所以我们在这要声明一个数组去保存结果，若成功的话则会把结果存到数组，所以我们在成功回调编写代码，我们可以用push方法去保存，但这就有一个瑕疵了，结果的顺序和数组的顺序有可能不相同的，因为先后改变的时间状态不一定，所以这里就是一个很巧妙的地方，见下列代码！！（很重要！！）arr[i] = v这行，我们利用元素在数组的下标对数据进行保存 4.失败的结果就很简单啦，若有一个promise为失败则直接调用reject就可以返回一个失败的promise了 12345678910111213141516171819202122232425262728//添加all方法Promise.all = function (promises) &#123; //返回为Promise对象 return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; //2. let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; //1. // promises[i].then(v =&gt; &#123; //得知对象的状态是成功 // resolve(); 不能这么写，需要遍历完数组再去调用该函数 count++; //2. //将当前promise对象成功的结果 存入到数组中 //arr.push(v); 这种方法会有瑕疵！！看上面分析的原因 arr[i] = v; //很巧妙的地方 //做一个判断 if (count === promises.length) &#123; //2. resolve(arr); &#125; &#125;, r =&gt; &#123; reject(r); &#125;) &#125; &#125;)&#125; ！！这样我们的all方法就封装好啦！！可以看下运行结果！ 第七步：race封装 我们的race方法呢，传入一个参数也是promise组成的数组，返回结果也是一个Promise对象，而这个对象的状态是由数组里面最先改变状态的promise状态，我们用内置的Promise看一下下面代码运行结果,p1先改变状态所以作为返回结果并且值为ok 1234567let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;Ok&#x27;);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;123&#x27;);let result = Promise.race([p1, p2, p3]);console.log(result) 实现这个方法同样也是需要遍历数组，race与all方法不一样，不需要遍历完整个数组再去判断是否为成功，谁先运行则直接返回该状态就好了，不知道大家能不能理解。race封装稍微简单一些 1234567891011121314//添加race方法Promise.race = function(promises)&#123; return new Promise((resolve,reject) =&gt; &#123; for(let i = 0; i &lt; promises.length ; i++)&#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为成功 resolve(v); &#125;,r =&gt; &#123; //修改返回对象的状态为失败 reject(r); &#125;) &#125; &#125;)&#125; 同样我们来验证自己写的代码是否正确 执行下列代码： 12345678910let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;Ok&#x27;); &#125;, 1000);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;123&#x27;);let result = Promise.race([p1, p2, p3]);console.log(result) 由于p1是经过一秒才改变状态，所以Promise.all返回的应该是p2的结果，我们来看下结果 最后一个步骤了！！！快大功告成 我们都知道Promise.then是一个异步执行任务而且是一个微任务，这可能牵扯到一点eventloop知识了，这里就不详细说eventloop知识啦，来举一个例子，我们用内置的Promise来运行下面代码，则控制台会输出111–&gt;333–&gt;222,因为会等同步代码运行完后才会去执行异步代码，用我们自己写的Promise,控制台则会输出111–&gt;222–&gt;333。 12345678let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;Ok&#x27;); console.log(&#x27;111&#x27;);&#125;)p1.then(value =&gt; &#123; console.log(&#x27;222&#x27;);&#125;)console.log(333); 我们需要怎么做才能让我们then是异步执行的呢，我们在then方法里面进行更改,我们在回调函数外面包一个settimeout函数使其变成异步任务(当然底层肯定不是这样实现的啦！！)只用看末尾有++++号的就是新增代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106function Promise(executor) &#123; //添加属性，一开始的状态为pending this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; // 声明属性 this.callbacks = []; //保存实例对象的this值 const self = this; //resolve 函数 function resolve(data) &#123; // 判断状态（解决状态可逆） if (self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;fulfilled&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; //调用成功的回调函数 setTimeout(() =&gt; &#123; //++++++++ self.callbacks.forEach(item =&gt; &#123; item.onResolved(data) &#125;) &#125;); &#125; //reject 函数 function reject(data) &#123; // 判断状态（解决状态可逆） if (self.PromiseState !== &#x27;pending&#x27;) return //修改对象状态（promiseState） self.PromiseState = &#x27;rejected&#x27;; //设置对象结果值（promiseResult） self.PromiseResult = data; //调用失败的回调函数 setTimeout(() =&gt; &#123; //++++++++ self.callbacks.forEach(item =&gt; &#123; item.onRejected(data) &#125;) &#125;); &#125; try &#123; //同步调用执行器函数,执行resolve和reject executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;//给原型添加then方法，这样实例对象可以用then方法Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; // 判断回调函数参数 if (typeof onRejected !== &#x27;function&#x27;) &#123; onRejected = reason =&gt; &#123; throw reason; &#125; &#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value; //value =&gt; &#123;return value&#125; &#125; return new Promise((resolve, reject) =&gt; &#123; //封装函数 function callback(type) &#123; try &#123; // 获取回调函数的执行结果 let result = type(self.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; //++++++++ callback(onResolved); &#125;); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; //++++++++ callback(onRejected); &#125;); &#125; if (this.PromiseState === &#x27;pending&#x27;) &#123; this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;) &#125; &#125;)&#125; 总结 本文还蛮长的，整理也整理了好久，当然面试的话通常不会让你手写一个完整的Promise，比较重要的是Promise.all和Promise.race方法这两个比较常考手写题！本人自己虽然写了两三遍Promise题但感觉还是蛮复杂的，要考虑的点蛮多的，所以一定要多敲代码！多敲代码！多敲代码！！重要的事情说三遍！如果喜欢的话可以点赞收藏，本人也是第一次写这么长的总结文章，如果有哪写的不好的地方，请大家谅解！有问题的话可以再评论区提出！后面附上手写Promise的源码放在github上面，有ES5版本的还有ES6用class写的版本","categories":[],"tags":[{"name":"项目总结分析","slug":"项目总结分析","permalink":"http://daniellin0516.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"}]},{"title":"webpack性能优化","slug":"webpack性能优化","date":"2021-12-01T12:14:17.000Z","updated":"2021-12-01T13:02:55.366Z","comments":true,"path":"2021/12/01/webpack性能优化/","link":"","permalink":"http://daniellin0516.github.io/2021/12/01/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"webpack性能优化 webpack性能优化主要分为两个方面： 开发环境性能优化 生产环境性能优化 开发环境性能优化优化打包构建速度HMR:模块热替换，若一个文件发生改变则只会重新构建该文件而不会整体文件再构建，提高打包构建速度 优化代码调试source-map:源代码到构建后代码映射的一个技术 inline-source-map,eval-source-map内联 开发常用内联模式 hidden-source-map,nosources隐藏源代码信息 生产多用外联模式 生产环境性能优化优化打包构建速度oneOf: 假如配置多个loader时，匹配到对应的loader就不会再进行往下查找,若一个文件需要loader比如eslint和babel，则需要把eslint放在oneof外面 babel缓存: 开启缓存后，运行结果会保存起来，第二次打包会更快一点 多进程打包: 默认是单进程打包，开启多进程打包后可以一次干多种事情 externals: 用cdn dll: 先把库打包好，在引用 优化代码运行的性能hash-chunkhash-contenthash： 缓存，一旦哈希值变则会重新生成文件，若不变则直接走缓存，hash指的是webpack打包后唯一生成的哈希值，chunkhash指的是若打包是来自于一个入口就等于一个同样的chunk，共享同一个哈希值，content-hash根据文件内容生成hash，若文件内容不变则哈希值不会变 tree-shaking: 去除用户中无用的代码 必须开启ES6模块化 将mode写成production则会默认开启tree-shaking，压缩代码 在package.json可以写sideEffect:[xx]，防止删除一些要用的代码 code split: 单页面的js太大进行代码分割 下面为设置的三种方式 设置多入口 设置optimization 通过import语法 在index.js文件设置 lazy-load: 懒加载/预加载（js代码懒加载） pwa: 离线可访问技术，由serviceworker和cache组成，主要作用在网站离线的时候也可以用，用户体验更好，兼容性问题有点大","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://daniellin0516.github.io/tags/webpack/"}]},{"title":"项目分析-Lemon——Heart","slug":"项目分析-Lemon——Heart","date":"2021-11-12T11:52:49.000Z","updated":"2021-11-12T13:51:25.468Z","comments":true,"path":"2021/11/12/项目分析-Lemon——Heart/","link":"","permalink":"http://daniellin0516.github.io/2021/11/12/%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90-Lemon%E2%80%94%E2%80%94Heart/","excerpt":"","text":"Lemon-Heart项目插件运用postcss-px-to-viewport 该插件是能够完成pc自适应布局的插件，利用vw进行布局，vw布局的页面是等比改变的(因为vw将屏幕等分为100份,在初始设计时某元素占屏幕多少份,在其他屏幕上也是同样的份数),比如我们在一个750px的屏幕宽度中使用了vw,当我们把屏幕宽度改为1920的时候,网页的整个样式包括字体都会等比放大.vw布局我用于大屏监控数据展示. 该插件作用是把style标签内的px在编译后转化为vw，我们在项目中写px，在执行npm run serve后 px转化为vw了 安装插件 1npm install postcss-px-to-viewport -D 在package.json同级下新建文件vue.config.js,在vue.config.js中配置如下 12345678910111213141516171819202122232425262728module.exports=&#123; css: &#123; extract: false,//false表示开发环境,true表示生成环境 sourceMap: false, loaderOptions: &#123; postcss: &#123; plugins: [ require(&quot;postcss-px-to-viewport&quot;)(&#123; unitToConvert: &quot;px&quot;, // 需要转换的单位，默认为&quot;px&quot; viewportWidth: 1920, // 视窗的宽度，对应pc设计稿的宽度，一般是1920 viewportHeight: 1080,// 视窗的高度，对应的是我们设计稿的高度,我做的是大屏监控,高度就是1080 unitPrecision: 3, // 单位转换后保留的精度 propList: [ // 能转化为vw的属性列表 &quot;*&quot; ], viewportUnit: &quot;vw&quot;, // 希望使用的视口单位 fontViewportUnit: &quot;vw&quot;, // 字体使用的视口单位 selectorBlackList: [], // 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。 minPixelValue: 1, // 设置最小的转换数值，如果为1的话，只有大于1的值会被转换 mediaQuery: false, // 媒体查询里的单位是否需要转换单位 replace: true, // 是否直接更换属性值，而不添加备用属性 exclude: /(\\/|\\\\)(node_modules)(\\/|\\\\)/, // 忽略某些文件夹下的文件或特定文件，例如 &#x27;node_modules&#x27; 下的文件 &#125;) ] &#125; &#125; &#125; &#125; animate.cssvue-cookieselement-UI按需引入组件用法 12345678910111213import &#123; Row,Col,Button,MenuItem,Menu,Skeleton,SkeletonItem,Card,Icon,Pagination,Alert &#125; from &#x27;element-ui&#x27;Vue.use(VueLazyload)Vue.component(Row);Vue.component(Col.name,Col);Vue.component(Button.name,Button);Vue.component(MenuItem.name,MenuItem);Vue.component(Skeleton.name,Skeleton);Vue.component(Menu.name,Menu);Vue.component(SkeletonItem.name,SkeletonItem);Vue.component(Card.name,Card);Vue.component(Icon.name,Icon);Vue.component(Pagination.name,Pagination);Vue.component(Alert.name,Alert); Canvas-next.js 动画粒子库，很不错的一个背景 安装 12345npm i vue-canvas-nest //如果使用淘宝镜像的话cnpm i vue-canvas-nest//或者yarnyarn add vue-canvas-nest 引入界面 12345678910111213141516171819import vueCanvasNest from &quot;vue-canvas-nest&quot;; export default &#123; data() &#123; return &#123; //配置属性 config: &#123; color: &quot;255, 255, 255&quot;, opacity: 1, zIndex: 5, count: 99, &#125;,//配置炫酷效果 &#125; &#125;, components: &#123; vueCanvasNest &#125;, methods: &#123;&#125;&#125;","categories":[],"tags":[{"name":"项目总结分析","slug":"项目总结分析","permalink":"http://daniellin0516.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"}]},{"title":"Express+搭建服务器","slug":"Express-搭建服务器","date":"2021-11-10T12:54:35.000Z","updated":"2021-11-22T08:04:04.753Z","comments":true,"path":"2021/11/10/Express-搭建服务器/","link":"","permalink":"http://daniellin0516.github.io/2021/11/10/Express-%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"搭建Node原生服务器 不借助任何第三方库，去搭建Node原生服务器 引入内置的http模块 12345let http = require(&#x27;http&#x27;)//引入一个内置模块，用于解析key = value&amp;key=value....这种形式的字符串为js中的对象//编码形式：urlencoded编码形式的参数，叫做：查询字符串参数//引入的qs是一个对象，该对象身上有很多用的方法，最具有代表性的：parse()let qs = require(&#x27;querystring&#x27;) 创造一个“服务员”,创建服务对象 让服务员开始干活，获取客人点的菜单 1234567let server = http.createServer(function(request,response)&#123; let params = request.url.split(&#x27;?&#x27;)[1] //获取客户端袖带过来的urlencoded:name=zhangsan&amp;age=18 let objParams = qs.parse(params) //&#123;name:&#x27;zhangsan&#x27;,age:18&#125; let &#123;name,age&#125; = objParams //解构赋值 response.setHeader(&#x27;content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;) //设置响应头 response.end(`你好$&#123;name&#125;,你的年龄是$&#123;age&#125;`) //提交内容&#125;) request:请求对象，里面包含客服端给服务器的东西 response：响应对象，里面包含服务器要返回给客户端的东西 指定服务器运行的端口号(绑定端口监听) 1234server.listen(3000,function(err)&#123; if(!err) console.log(&#x27;服务器启动成功了&#x27;) else console.log(err)&#125;) express框架 引入express 1const express = require(&#x27;express&#x27;) 创建app服务对象 1const app = express() 配置路由—对请求的url进行分类，服务器根据分类决定交给谁去处理 根据路由定义的顺序（写代码的顺序），依次定义好路由，随后放入一个类似数组的结构，当有请求时，依次取出匹配，若匹配成功，不再继续匹配 123456789101112//根路由app.get(&#x27;/&#x27;,function(request,response)&#123; response.send(&#x27;我是主页&#x27;)&#125;)//一级路由app.get(&#x27;/meishi&#x27;,function(request,response)&#123; response.send(&#x27;我是美食页面1&#x27;)&#125;)//一级路由 该路由不进行匹配app.get(&#x27;/meishi&#x27;,function(request,response)&#123; response.send(&#x27;我是美食页面2&#x27;)&#125;) 指定服务器运行的端口号 1234app.listen(3000,function(err)&#123; if(!err) console.log(&#x27;服务器启动成功了&#x27;) else console.log(err)&#125;) 整体的一个搭建服务器代码1234567891011const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;,function(request,response)&#123; response.send(&#x27;我是主页&#x27;) console.log(request.query)&#125;)app.listen(3000,function(err)&#123; if(!err) console.log(&#x27;服务器启动成功了&#x27;) else console.log(err)&#125;) request对象的属性 request.query 获取查询字符串参数（query参数），拿到的是一个对象 12345678910let express = require(&#x27;express&#x27;)let app = express()app.get(&#x27;/&#x27;,function(request,response)&#123; console.log(request.query) response.send(&#x27;ok&#x27;)&#125;)app.listen(3000,function(err)&#123; if(!err) console.log(&#x27;ok&#x27;) else console.log(err)&#125;) 得到的参数如图下所示 request.params 获取get请求参数路由的参数，拿到的是一个对象 12345678910let express = require(&#x27;express&#x27;)let app = express()app.get(&#x27;/demo/:id&#x27;,function(request,response)&#123; let &#123;id&#125; = request.params response.send(`我是$&#123;id&#125;`)&#125;)app.listen(3000,function(err)&#123; if(!err) console.log(&#x27;ok&#x27;) else console.log(err)&#125;) request.body 获取post请求体，拿到的是一个对象，要借助一个中间件 request.get(xxx) 123456789101112let express = require(&#x27;express&#x27;)let app = express()app.get(&#x27;/&#x27;,function(request,response)&#123; console.log(request.query) console.log(request.get(&#x27;Host&#x27;)) console.log(request.get(&#x27;Referer&#x27;)) response.send(&#x27;ok&#x27;)&#125;)app.listen(3000,function(err)&#123; if(!err) console.log(&#x27;ok&#x27;) else console.log(err)&#125;) 输出结果： response对象属性response.send()：给浏览器做出一个响应 reponse.end()：给浏览器做出一个响应 response.download：告诉浏览器下载一个文件 response.sendFile()：给浏览器下载一个文件 response.redirect():服务器告诉浏览器重定向 1response.redirect(&#x27;http://www.baidu.com&#x27;) response.set(header,value):自定义响应头内容 response.get(key):获取响应头指定key对应的value res.status(code)：设置响应状态码 全局应用级中间件12345aoo.use((request,response,next)=&gt;&#123; //response.send(&#x27;&#x27;) //1.过滤一些合法的请求 next() //放行&#125;) 在express中，定义路由和中间件的时候，根据定义的顺序，将定义的每一个中间件或路由，放在一个类似与数组的容器中，当请求过来时，依次从容器中取出中间件和路由，进行匹配，如果匹配成功，将由该路由或中间件处理，如果全局中间件写在最开始的位置，name就是请求的“第一扇门” 对于服务器来说，依次请求，只有一个请求对象民和一个响应对象，其他任何的request和response都是对二者的引用 图片防盗链 123456789101112app.use((request, response, next) =&gt; &#123; if (request.get(&#x27;Referer&#x27;)) &#123; let mini = request.get(&#x27;Referer&#x27;).split(&#x27;/&#x27;)[2] if (mini === &#x27;127.0.0.1:5500&#x27;) &#123; next() &#125; else &#123; response.sendFile(__dirname +&#x27;/pubilc.error.png&#x27;) &#125; &#125; else &#123; next() &#125;&#125;) 第二种函数全局应用级中间件用法1234567891011121314151617181920212223242526272829303132const e = require(&#x27;express&#x27;)const express = require(&#x27;express&#x27;)const app = express()function demo(request, response, next) &#123; if (request.get(&#x27;Referer&#x27;)) &#123; let mini = request.get(&#x27;Referer&#x27;).split(&#x27;/&#x27;)[2] if (mini === &#x27;127.0.0.1:5500&#x27;) &#123; next() &#125; else &#123; response.sendFile(__dirname + &#x27;/pubilc.error.png&#x27;) &#125; &#125; else &#123; next() &#125;&#125;app.get(&#x27;/&#x27;, (request, response) =&gt; &#123; response.send(&#x27;ok&#x27;)&#125;)app.get(&#x27;/demo&#x27;, (request, response) =&gt; &#123; console.log(request.query) response.send(&#x27;ok2&#x27;)&#125;)app.get(&#x27;/picture&#x27;,demo, (request, response) =&gt; &#123; //只在picture路由使用 response.sendFile(__dirname + &#x27;/public/demo.jpg&#x27;)&#125;)app.listen(3000, function (err) &#123; if (!err) console.log(&#x27;已经启动&#x27;) else console.log(err)&#125;) 优点：更加灵活，不是第一扇门，可以在任何地方使用 第三方中间件npm add body-parser用于解析post参数 引入： 1const bodyParser = require(&#x27;body-parser&#x27;) 用法： 1app.use(bodyParser.urlencoded(&#123;extended: true&#125;)) 解析post请求请求体中所携带的unrlencoded编码形式的参数为一个对象，随后挂载到request对象 使用内置中间件去暴露静态资源–一次性把你所指定的文件内的资源全部交出去 1app.use(express.static(__dirname + &#x27;/public&#x27;))","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://daniellin0516.github.io/tags/NodeJs/"}]},{"title":"mangoose使用","slug":"mangoose使用","date":"2021-10-30T07:54:26.000Z","updated":"2021-11-01T02:34:08.397Z","comments":true,"path":"2021/10/30/mangoose使用/","link":"","permalink":"http://daniellin0516.github.io/2021/10/30/mangoose%E4%BD%BF%E7%94%A8/","excerpt":"","text":"mongoose monogoDB:一个数据库品牌的名字 mingod:启动数据库的命令 monogo：连接数据库的命令 mongoose：在Node平台下，一个知名的用于帮助开发者 写代码连接数据库，借助第三方的一个包 mongoose在node平台下，更加简单，高效，安全，稳定的操作mongoDB 使用方法引入mongoose1let mongoose = require(&#x27;mongoose&#x27;) 1.连接数据库1234mongoose.connect(&#x27;mongodb://localhost:27017/demo&#x27;,&#123; useNewUrlParser:true, //使用一个新的URL解析器，用于解决一些安全性问题 useUnifiedTopology:true //使用一个统一的新的拓扑结构&#125;) 2.绑定数据库连接的监听1234567mongoose.connection.on(&#x27;open&#x27;, function (err) &#123; if (err) &#123; console.log(&#x27;数据库链接失败&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功&#x27;) &#125;&#125; 3.引入模式对象（请来一个帮你看门的保安）1234567891011mongoose.connection.on(&#x27;open&#x27;, function (err) &#123; if (err) &#123; console.log(&#x27;数据库链接失败&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功&#x27;) //3.操作数据库 console.log(&#x27;操作数据库&#x27;) //1.请来一个帮你看门的保安 ----引入模式对象 let Schema = mongoose.Schema &#125;&#125; 4.创建约束对象（制定你家的规则）1234567891011121314151617181920212223242526272829303132333435363738394041mongoose.connection.on(&#x27;open&#x27;, function (err) &#123; if (err) &#123; console.log(&#x27;数据库链接失败&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功&#x27;) //3.操作数据库 console.log(&#x27;操作数据库&#x27;) //1.请来一个帮你看门的保安 ----引入模式对象 let Schema = mongoose.Schema //2.制定你家的规则 ----创建约束对象 let studentsRule = new Schema(&#123; stu_id:&#123; type:String,//限制学号必须为字符串 required:true, //限制学号为必填项 unique:true //限制学号是唯一的 &#125;, name:&#123; type:String,//限制姓名必须为字符串 required:true, //限制姓名为必填项 &#125;, age:&#123; type:Number,//限制年龄必须为字符串 required:true, //限制年龄为必填项 &#125;, sex:&#123; type:String,//限制性别必须为字符串 required:true, //限制性别为必填项 &#125;, hobby:[String], //限制爱好只能为数组，数组中的每一项必须为字符串 info:Schema.Types.Mixed, //接收所有类型 date:&#123; type:Date, default:Date.now() &#125;, enable_flag:&#123; type:String, default:true &#125; &#125;)&#125; 5.创建模型对象（告诉保安你的规则）12345678910111213141516171819202122232425262728293031323334353637383940414243mongoose.connection.on(&#x27;open&#x27;, function (err) &#123; if (err) &#123; console.log(&#x27;数据库链接失败&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功&#x27;) //3.操作数据库 console.log(&#x27;操作数据库&#x27;) //1.请来一个帮你看门的保安 ----引入模式对象 let Schema = mongoose.Schema //2.制定你家的规则 ----创建约束对象 let studentsRule = new Schema(&#123; stu_id:&#123; type:String,//限制学号必须为字符串 required:true, //限制学号为必填项 unique:true //限制学号是唯一的 &#125;, name:&#123; type:String,//限制姓名必须为字符串 required:true, //限制姓名为必填项 &#125;, age:&#123; type:Number,//限制年龄必须为字符串 required:true, //限制年龄为必填项 &#125;, sex:&#123; type:String,//限制性别必须为字符串 required:true, //限制性别为必填项 &#125;, hobby:[String], //限制爱好只能为数组，数组中的每一项必须为字符串 info:Schema.Types.Mixed, //接收所有类型 date:&#123; type:Date, default:Date.now() &#125;, enable_flag:&#123; type:String, default:true &#125; &#125;) //3.告诉保安你的规则 ----创建模型对象 let stuModel = mongoose.model(&#x27;students&#x27;,studentsRule) //用于生成某个模型对象&#125; 6.CRUD（真正有人要进入你家了）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//2.绑定数据库连接的监听mongoose.connection.on(&#x27;open&#x27;, function (err) &#123; if (err) &#123; console.log(&#x27;数据库链接失败&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功&#x27;) //3.操作数据库 console.log(&#x27;操作数据库&#x27;) //1.请来一个帮你看门的保安 ----引入模式对象 let Schema = mongoose.Schema //2.制定你家的规则 ----创建约束对象 let studentsRule = new Schema(&#123; stu_id:&#123; type:String,//限制学号必须为字符串 required:true, //限制学号为必填项 unique:true //限制学号是唯一的 &#125;, name:&#123; type:String,//限制姓名必须为字符串 required:true, //限制姓名为必填项 &#125;, age:&#123; type:Number,//限制年龄必须为字符串 required:true, //限制年龄为必填项 &#125;, sex:&#123; type:String,//限制性别必须为字符串 required:true, //限制性别为必填项 &#125;, hobby:[String], //限制爱好只能为数组，数组中的每一项必须为字符串 info:Schema.Types.Mixed, //接收所有类型 date:&#123; type:Date, default:Date.now() &#125;, enable_flag:&#123; type:String, default:true &#125; &#125;) //3.告诉保安你的规则 ----创建模型对象 let stuModel = mongoose.model(&#x27;students&#x27;,studentsRule) //用于生成某个模型对象 //4.真正有人要进入你家了 -----CRUD stuModel.create(&#123; stu_id:&#x27;004&#x27;, name:&#x27;班长&#x27;, age:21, sex:&#x27;男&#x27;, hobby:[&#x27;打游戏&#x27;,&#x27;学高数&#x27;,&#x27;学习&#x27;], info:&#x27;可爱的男子&#x27;, &#125;,function(err,data)&#123; if(!err) console.log(data) else console.group(err) &#125;) &#125;&#125;) CRUD操作新增操作对象.create 1234567891011对象.create(&#123; stu_id:&#x27;004&#x27;, name:&#x27;班长&#x27;, age:21, sex:&#x27;男&#x27;, hobby:[&#x27;打游戏&#x27;,&#x27;学高数&#x27;,&#x27;学习&#x27;], info:&#x27;可爱的男子&#x27;,&#125;,function(err,data)&#123; if(!err) console.log(data) else console.log(err)&#125;) 查询操作对象.find find方法： 1.返回的事一个数组，就算是一条数据，也包裹成一个数组 2.若查询结果为空，则返回一个空数组 1234stuModel.find(&#123;name:&#x27;蒨&#x27;&#125;,function(err,data)&#123; if(!err) console.log(data) else console.log(err)&#125;) 对象.findone 1.若有结果，返回的是一个对象 2.若没有结果，返回一个null 1234stuModel.findone(&#123;name:&#x27;蒨&#x27;&#125;,function(err,data)&#123; if(!err) console.log(data) else console.log(err)&#125;) 更新操作对象.updateOne 对象.updateMany 1234stuModel.updateOne(&#123;name:&#x27;谢雨蒨&#x27;&#125;&#123;age:22&#125;,function(err,data)&#123;if(!err) console.log(data)else console.log(err)&#125;) 删除操作对象.deleteMany","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://daniellin0516.github.io/tags/NodeJs/"}]},{"title":"Buffer缓冲器","slug":"Buffer缓冲器","date":"2021-10-18T06:44:46.000Z","updated":"2021-10-20T11:03:52.983Z","comments":true,"path":"2021/10/18/Buffer缓冲器/","link":"","permalink":"http://daniellin0516.github.io/2021/10/18/Buffer%E7%BC%93%E5%86%B2%E5%99%A8/","excerpt":"","text":"Buffer缓冲器Buffer是什么Buffer是一个和数组类似的对象，不同是Buffer是专门用来保存二进制数据的。 Buffer特点 它是一个类似于数组的对象，用于存储数据（存储的是二进制数据） Buffer的效率很高，存储和读取很快，它是直接对计算机的内存进行操作 每个元素大小为1字节（byte） Buffer大小一旦确定了，不可修改 Buffer是Node中的非常核心的模块，无需下载，无需引入，直接即可使用 创建123456789//创建一个Buffer的实例对象------性能特别差--1.在堆里开辟空间2.清理let buf = new Buffer(10)console.log(buf)//创建一个Buffer实例对象-------性能比new Buffer（)稍强一点点-----在堆中开辟一块空间(该块空间没有人)let buf2 = Buffer.alloc(10)console.log(buf2)//创建一个Buffer实例对象-------性能最好的----在堆里开辟空间let buf3 = Buffer.allocUnsafe(10)console.log(buf3) 输出的Buffer为什么不为空？ 在堆里开辟空间，可能残留着别人用过的数据，所以allocUnsafe 将一个数据存入12let buf4 = Buffer.from(&#x27;hello atguigu&#x27;)console.log(buf4) Node简单文件写入简单文件写入1.Node中的文件系统： 1.NodeJs中有一个文件系统，所谓的文件系统，就是对计算机中的文件进行增删改查等操作 2.在NodeJs中，给我们提供一个模块，叫做fs模块，专门用于操作文件 3.fs模块是Node的核心模块，使用的时候，无需下载，直接引入 2.异步文件写入（简单文件写入） fs.writeFile(file,data[,options],callback) file：要写入文件路径+文件名 data：要写入的数据 options：可选参数（可选参数） encoding：设置文件的编码方式，默认值：&#39;utf8&#39; mode：设置文件的操作权限，默认值： 0o666=0o222+0o444 0o111:文件可被执行的权限 0o222:文件可被写入的权限 0o444:文件可被读取的权限 flag:打开文件要执行的操作， 默认值: &#39;w&#39; a：追加 w：写入 signal allows aborting an in-progress writeFile callback：回调函数 err：错误对象 在Node中有这样一个原则：错误优先 1234567891011//引入内置的fs模块let fs = require(&#x27;fs&#x27;)//调用writeFile方法fs.writeFile(&#x27;./demo.txt&#x27;,&#x27;今天天气真不错&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(&#x27;文件写入失败&#x27;,err) &#125;else&#123; console.log(&#x27;文件写入成功&#x27;) &#125;&#125;) 流式文件写入fs.createWriteStream(path[,optoions]) path:要写入文件的路径+文件名+文件后缀 options:配置对象（可选参数） flags：打开文件要执行的操作， 默认值: &#39;w&#39; encoding：设置文件的编码方式，默认值：&#39;utf8&#39; fd:文件统一标识符，Linux下文件标识符 mode: autoClose：自动关闭—文件，默认值：true emitClose：强制关闭—文件，默认值：false start:写入文件的起始位置（偏移量） 123456789101112131415161718let fs = require(&#x27;fs&#x27;)//创建可写流let ws = fs.createWriteStream(__dirname+&#x27;/demo.txt&#x27;)//监测流的状态ws.on(&#x27;open&#x27;,function()&#123; console.log(&#x27;可写流打开了&#x27;)&#125;)ws.on(&#x27;close&#x27;,function()&#123; console.log(&#x27;可写流关闭了&#x27;)&#125;)//使用可写流写入数据ws.write(&#x27;美女\\n&#x27;)ws.write(&#x27;没诶诶诶\\n&#x27;)ws.write(&#x27;到底是哪一个\\n&#x27;)ws.close() //如果在node8版本，用此方法，会造成数据丢失 简单文件读取fs.readFile(path[,path],callback): path:读取文件的路径+文件名+后缀 options:配置对象（可选） callback:回调 err:错误对象 data:读取出来的数据 123456789101112131415161718192021//简单文件写入和简单文件读取，都是一次性把所有要读取或要写入的内容加到内存中，很容易造成内存泄漏let fs = require(&#x27;fs&#x27;)fs.readFile(__dirname+&#x27;/demo.txt&#x27;,function(err,data)&#123; if(err)&#123; console.log(&#x27;文件读取失败&#x27;,err) &#125;else&#123; console.log(&#x27;文件读取成功&#x27;,data) fs.writeFile(&#x27;./haha.txt&#x27;,data,function(err)&#123; if(err)&#123; console.log(&#x27;文件写入失败&#x27;,err) &#125;else&#123; console.log(&#x27;文件写入成功&#x27;) &#125; &#125;) &#125;&#125;)/* 为什么读取出来的东西是buffer？用户存储的不一定是纯文本*/ 流式文件读取fs.createWriteStream(path[,optoions]): path:要读取的文件路径+文件名+后缀 options: flags encoding fd mode autoClose emitClose start：起始偏移量 end:结束偏移量 highWaterMark:控制每次读取数据的大小，默认值：64kb 12345678910111213141516let &#123;createReadStream&#125; = require(&#x27;fs&#x27;)//创建一个可读流let rs = createReadStream(__dirname+&#x27;/demo.txt&#x27;,&#123;highWaterMark:10*1024*1024&#125;)//监测流的状态rs.on(&#x27;open&#x27;,function()&#123; console.log(&#x27;可读流打开了&#x27;)&#125;)rs.on(&#x27;close&#x27;,function()&#123; console.log(&#x27;可读流关闭了&#x27;)&#125;)//给可读流绑定一个data事件，就会触发可读流自动读取内容rs.on(&#x27;data&#x27;,function(data)&#123; //buffer实例的length属性，是表示该buffer实例占用内存空间的大小 console.log(data.length) //输出的时65536，每次读取64kb内容&#125;)","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://daniellin0516.github.io/tags/NodeJs/"}]},{"title":"NodeJs简介","slug":"NodeJs简介","date":"2021-10-17T08:44:43.000Z","updated":"2021-10-18T04:23:14.445Z","comments":true,"path":"2021/10/17/NodeJs简介/","link":"","permalink":"http://daniellin0516.github.io/2021/10/17/NodeJs%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Node.js优点优点 1.异步非阻塞的I/O（I/O线程池） 2.特别适用于I/O密集型应用 3.事件循环机制 4.单线程（成也单线程，败也单线程） 5.跨平台 缺点 1.回调函数嵌套太多，太深（俗称回调地狱） 2.单线程，处理不好CPU密集型任务 node中的函数通过argument.callee.toString()可以看到一个函数“ 1function (exports, require, module, __filename, __dirname) &#123;&#125; 这个函数是所有模块都有的，node编译时往其中注入5个参数： exports 暴露模块 require 引入模块 module exports属性暴露模块 __filename 文件的绝对路径 _dirname 文件夹的绝对路径 node中的事件循环模型 第一个阶段：timers(定时器阶段–setTimeout,setInterval) 开始计时 执行定时器的回调 第二个阶段：pending callbacks(系统阶段) 第三个阶段：idle,prepare(准备阶段) 第四个阶段：poll(轮询阶段，核心) 如果回调队列有待执行的回调函数 从回调队列中取出回调函数同步执行(一个一个执行)，直到回调队列为空了，或者达到系统最大限度 如果回调队列为空 如果有设置过setImmediate,进入下一个check阶段,目的：为了执行setImmediate所设置的回调 如果未设置过setImmediate，在此阶段停留，等待回调函数被插入回调队列，若定时器到点了进入下一个check阶段，目的：为了走第五阶段，随后走第六阶段，随后第一阶段(最后目的) 第五个阶段：check(专门用于执行setImmediate所设置的回调) 第六个阶段：close callbacks(关闭回调阶段) 包和包管理器 包实际上就是一个压缩文件，解压以后还原为目录。符合CommonJs规范的目录，应该包含如下文件和文件夹 1.package.json 描述文件(包的说明书，必须要有！！) 2.bin 可执行二进制文件 3.lib js代码 4.doc 文档 5.test 单元测试 npm是什么1全称：Node Package Manager , Node的包管理器 npm常用命令 搜索 1npm search xxxxx 安装 1. 12345npm install xxxx --save//或npm i xxxx -S//或npm i xxxx 2. 1234npm install xxxx --asve-dev //或npm i xxxx -D//安装包并将该包写入到(开发依赖中development) 生产（代码写完了，部署到服务器上，给客户用）依赖(dependendcies)： Jquery、bootstrap等 开发（程序员正在写代码的时候，正在写代码的时候）依赖(devDependencies)：语法检查、压缩代码、扩展css前缀，Jquery、编译less的包 注意：某些包既属于开发依赖、又属于生产依赖—例如jquery 1npm i xxxx -g //全局安装xxxx包 一般来说，带有指令集的包要进行全局安装，例如：browserify、babel等，全局安装的包，其指令到处可用，如果该包不带有指令，就无需全局安装 查看全局安装的位置： 1npm root -g 4. 安装xxxx包的xx版本 1npm i xxxx@xxx 移除 1npm remove xxxx //在nodemodule删除xxx包，同时会删除package.json的声明 其他命令 1234npm aduit fix //检测项目依赖一些问题，并且尝试修复npm view xxxx versions //查看远程npm仓库中xxx包所有版本信息npm view xxx version //查看npm仓库中xxx包最新版本信息npm ls xxx //查看我们所安装的xxx包的版本 关于版本号的说明 “^3.x.x”:锁定大版本，以后安装包的时候，保证包是3.x.x版本，x默认取最新的 “~3.1.x”锁定小版本，以后安装包的时候，保证包是3.1.x版本，x默认取最新的 “3.1.1”锁定完整版本，以后安装包的时候，保证包是3.1.1版本 yarn常用命令","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://daniellin0516.github.io/tags/NodeJs/"}]},{"title":"模块化","slug":"模块化","date":"2021-10-13T03:27:49.000Z","updated":"2021-10-13T04:48:48.624Z","comments":true,"path":"2021/10/13/模块化/","link":"","permalink":"http://daniellin0516.github.io/2021/10/13/%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"模块化 模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来 模块化的好处模块化的优势有以下几点： 1.防止命名冲突 2.代码复用 3.高维护性 模块功能主要由两个命令构成：export和import export命令用于规定模块的对外接口 import命令用于输入其他模块提供的功能 模块暴露数据语法汇总1234567891011121314151617181920212223242526//分别暴露export let school = &#x27;123&#x27;export function()&#123; console.log(&#x27;我们可以教给你开发技能&#x27;)&#125;//统一暴露let school = &#x27;123&#x27;findJob()&#123; console.log(&#x27;我们可以帮助你&#x27;)&#125;export &#123;school, findJob&#125;//引入模块import * as m2 from &#x27;./src/js/m2.js&#x27;//默认暴露export default&#123; school:&#x27;atg&#x27;, change: function()&#123; console.log(&#x27;我么可以&#x27;) &#125;&#125;//引入import * as m3 from &#x27;./src/js/m3.js&#x27;//用change方法m3.default.change() 模块引入数据语法汇总12345678910//1.通用的导入方式import * as m1 from &#x27;./src/js/m1.js&#x27;//2.解构赋值形式import &#123;school,teach&#125; from &#x27;./src/js/m1.js&#x27;import &#123;default * as m3&#125; from &#x27;./src/js/m3.js&#x27;//3.简便形式 针对默认暴露import m3 from &#x27;./src/js/m3.js&#x27;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"}]},{"title":"集合、Map、class","slug":"集合、Map、class","date":"2021-10-12T08:11:29.000Z","updated":"2021-10-13T01:50:44.826Z","comments":true,"path":"2021/10/12/集合、Map、class/","link":"","permalink":"http://daniellin0516.github.io/2021/10/12/%E9%9B%86%E5%90%88%E3%80%81Map%E3%80%81class/","excerpt":"","text":"集合介绍与API声明一个set1234//声明一个setlet s = new Set();let s2 = new Set([&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;])console.log(s2) 元素个数1console.log(s2.size) 添加新的元素12s2.add(&#x27;5&#x27;)console.log(s2) 删除元素1s2.delete(&#x27;4&#x27;) 检测1s2.has(&#x27;1&#x27;) //检测set里面是否有1 有的话就就返回true 清空1s2.clear() 遍历123for(let v of s2)&#123; console.log(v)&#125; 集合实践12345678910111213141516171819let arr = [1,2,3,4,5,4,3,2,1]//1.数组去重let result = [...new Set(arr)]console.log(result)//2.交集let arr2 = [4,5,6,5,6,]let result = [...new Set(arr)].filter(item =&gt; &#123; let s2 = new Set(arr2) if(s2.has(item))&#123; return true &#125;else&#123; return false &#125;&#125;)console.log(result)//3.并集let result = [...new Set([...arr, ...arr2])]//4.差集let diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item))) Map声明一个Map1let m = new Map() 添加元素12345678m.set(&#x27;name&#x27;,&#x27;尚硅谷&#x27;)let key = &#123; school:&#x27;heiheihei&#x27;&#125;m.set(key,[&#x27;bj&#x27;,&#x27;sh&#x27;,&#x27;shenzhen&#x27;])console.log(m)//sizeconsole.log(m.size) //2 删除1m.delete(&#x27;name&#x27;) 获取1console.log(m.get(&#x27;name&#x27;)) //get后面跟键值 清空1m.clear() 遍历123for(let v of m)&#123; console.log(v)&#125; Class1234567891011121314151617181920212223242526272829ES5//手机function Phone(brand,price)&#123; this.brand = brand this.price = price&#125;//添加方法Phone.prototype.call = function()&#123; console.log(&#x27;我可以打电话&#x27;)&#125;//实例化对象let Huawei = new Phone(&#x27;华为&#x27;,5999)Huawei.call()console.log(Huawei)ES6class Phone&#123; //构造方法 名字不能修改 constructor(brand,price)&#123; this.brand = brand this.price = price &#125; //方法必须使用该㞏，不能使用ES5的对象完整形式 call()&#123; console.log(&#x27;我可以打电话&#x27;) &#125;&#125;let oneplus = new Phone(&#x27;1+&#x27;,1999)console.log(onePlus) ES5构造函数继承123456789101112131415161718192021222324function Phone(brand,price)&#123; this.brand = brand this.price = price&#125;Phone.prototype.call = function()&#123; console.log(&#x27;我可以打电话&#x27;)&#125;function SmartPhone(brand,price,color,size)&#123; Phone.call(this,brand,price) this.color = color this.size = size&#125;//设置子级构造函数的原型SmartPhone.prototype == new PhoneSmartPhone.prototype.constructor = SmartPhone//声明子类的方法SmartPhone.prototype.photo = function()&#123; console.log(&#x27;我可以拍照&#x27;)&#125;Smartphone.prototype.playGame = function()&#123; console.log(&#x27;我可以玩游戏&#x27;)&#125;const chuizi = new SmartPhone(&#x27;锤子&#x27;,&#x27;2499&#x27;,&#x27;黑色&#x27;,&#x27;5.5inch&#x27;)console.log(chuizi) class类继承1234567891011121314151617181920212223242526class Phone&#123; //构造方法 constructor(brand,price)&#123; this.brand = brand this.price = price &#125; //父类的成员属性 call()&#123; console.log(&#x27;我可以打电话&#x27;) &#125;&#125;class SmartPhone extends Phone&#123; //构造方法 constructor(brand,price,color,size)&#123; super(brand,price) this.color = color this.size = size &#125; photo()&#123; console.log(&#x27;拍照&#x27;) &#125; playGame()&#123; console.log(&#x27;玩游戏&#x27;) &#125;&#125;const xiaomi = new SmartPhone(&#x27;小米&#x27;,799,&#x27;黑色&#x27;,&#x27;4.&#x27;)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"}]},{"title":"Promise","slug":"Promise","date":"2021-10-12T01:08:20.000Z","updated":"2021-10-12T08:02:44.628Z","comments":true,"path":"2021/10/12/Promise/","link":"","permalink":"http://daniellin0516.github.io/2021/10/12/Promise/","excerpt":"","text":"Promise Promise是ES6异步编程的新解决方案。语法上Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果 1234567891011121314151617//实例化 Promise对象const p = new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; // //let data=&#x27;数据库中的用户数据&#x27;; //resolve //resolve(data); let err = &#x27;数据读取失败&#x27;; reject(err) &#125;,1000) &#125;) //调用promise对象的then方法 p.then(function(value)&#123; console.log(value); &#125;,function(reason)&#123; console.error(reason) &#125;) Promise封装读取文件1234567891011121314151617181920212223242526//1.引入fs模块const fs = require(&#x27;fs&#x27;)//2.调用方法读取文件// fs.readFile(&#x27;./resources/包含min函数的栈.md&#x27;,(err,data)=&gt;&#123;// //如果失败，则抛出错误// if(err) throw err;// //如果没有出错，则输出内容// console.log(data.toString())// &#125;);//3.使用Promise封装const p = new Promise(function (resolve, reject) &#123; fs.readFile(&#x27;./resources/包含min函数的栈.md&#x27;, (err, data) =&gt; &#123; //判断如果失败 if(err) reject(err); //如果成功 resolve(data); &#125;)&#125;)p.then(function(value)&#123; console.log(value.toString())&#125;,function(reason)&#123; console.log(&#x27;读取失败！&#x27;)&#125;) 发送Ajax请求123456789101112131415161718192021222324252627 //接口地址：https://api.apiopen.top/getJoke //1.创建对象 const p = new Promise((resolve,reject)=&gt;&#123; const xhr = new XMLHttpRequest(); //2.初始化 xhr.open(&#x27;GET&#x27;,&#x27;https://api.apiopen.top/getJoke&#x27;); //3.发送 xhr.send(); //4.绑定事件，处理响应结果 xhr.onreadystatechange = function()&#123; //判断 if(xhr.readyState === 4)&#123; //判断响应状态码 if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300)&#123; resolve(xhr.response) &#125;else&#123; //如果失败 reject(xhr.status) &#125; &#125; &#125;&#125;)p.then(function(value)&#123; console.log(value);&#125;,function(reason)&#123; console.error(reason)&#125;) Promise.prototype.then12345678910111213141516171819202122232425262728293031//创建promise对象const p = new Promise((resolve,reject)=&gt;&#123; setTimeout(() =&gt; &#123; resolve(&#x27;用户数据&#x27;) // reject(&#x27;出错啦&#x27;) &#125;, 1000);&#125;)//调用then方法 then方法的返回结果是Promise对象，对象状态由回调函数的执行结果决定//1.如果回调函数中返回的结果是 非Promise的属性，状态为成功，返回值为 对象的成功值// const result = p.then(value =&gt; &#123;// console.log(value)// //1.非 promise 类型的属性// //return 123;// //2.是 promise对象// // return new Promise((resolve,reject)=&gt;&#123;// // // resolve(&#x27;ok&#x27;)// // // reject(&#x27;error&#x27;)// // &#125;)// //3.抛出错误// throw new Error(&#x27;出错啦!&#x27;)// &#125;,reason =&gt; &#123;// console.warn(reason)// &#125;)//链式调用p.then(value=&gt;&#123; &#125;,reason =&gt;&#123;&#125;).then(value=&gt;&#123;&#125;,reason=&gt;&#123;&#125;)console.log(result) catch方法123456789101112const p = new Promise((resolve,reject)=&gt;&#123; setTimeout(() =&gt; &#123; //设置p对象的状态为失败，并设置失败的值 reject(&#x27;出错啦！&#x27;) &#125;, 1000);&#125;)// p.then(function(value)&#123;&#125;,function(reason)&#123;// console.error(reason)// &#125;)p.catch(function(reason)&#123; console.warn(reason)&#125;)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"}]},{"title":"Symbol、迭代器、生成器","slug":"Symbol、迭代器、生成器","date":"2021-10-10T03:26:27.000Z","updated":"2021-10-11T08:23:13.004Z","comments":true,"path":"2021/10/10/Symbol、迭代器、生成器/","link":"","permalink":"http://daniellin0516.github.io/2021/10/10/Symbol%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"Symbol基本使用 ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是Javascript语言的第七种数据类型，是一种类似于字符串的数据类型。 Symbol特点： Symbol的值是唯一的，用来解决命名冲突的问题 Symbol值不能与其他数据进行运算 Symbol定义的对象属性不能使用for...in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名 创建Symbol123456789let s = Symbol();let s2 = Symbol(&#x27;嘿嘿嘿&#x27;)let s3 = Symbol(&#x27;嘿嘿嘿&#x27;)console.log(s2===s3) //false//Symbol.for创建let s4 = Symbol.for(&#x27;嘿嘿嘿&#x27;)let s5 = Symbol.for(&#x27;嘿嘿嘿&#x27;)console.log(s4===s5) //true 不能与其他数据进行运算123let result = s + 100 //报错let result = s &gt; 100 //报错let result = s + &#x27;100&#x27; //报错 对象添加Symbol类型的属性123456789101112let game&#123;…//声明一个对象let methods = &#123; up:Symbol(), down:Symbol()&#125;;game[methods.up] = function()&#123; console.log(&#x27;我可以改变形状&#x27;)&#125;geme[methods.down] = function()&#123; console.log(&#x27;我可以下降&#x27;)&#125; Symbol的内置属性hasInstance属性 123456789class Person&#123; static [Symbol.hasInstance](param)&#123; console.log(param) console.log(&#x27;我被用来检测类型了&#x27;) return false &#125;&#125;let o = &#123;&#125;console.log(o instanceof Person) isConcatSpreadable属性 1234const arr=[1,2,3]const arr2 = [4,5,6]arr2[Symbol.inConcatSpreadable] = false; //表示是否可以展开console.log(arr.concat(arr2)) 迭代器 迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Interator接口，就可以完成遍历操作 1.ES6创造了一种新的遍历命令for…of循环，Interator接口主要供for…of消费 2.原生iterator接口的数据 Array Arguements Set Map String TypedArray NodeList 工作原理 创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员 每调用next方法返回一个包含value和done属性的对象 1234567const xiyou = [&#x27;唐僧&#x27;,&#x27;孙悟空&#x27;,&#x27;猪八戒&#x27;,&#x27;沙僧&#x27;]let iterator = xiyou[Symbol.iterator]();//调用对象的next方法console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator.next()) 迭代器的应用123456789101112131415161718192021222324252627282930//声明一个对象const banji = &#123; name:&#x27;终极一班&#x27;, stus:[ &#x27;xiaoming&#x27;, &#x27;xiaoning&#x27;, &#x27;xiaotian&#x27;, &#x27;knight&#x27; ], [Symbol.interator]()&#123; //索引变量 let index = 0 // let _this = this return &#123; next: function()&#123; if(index &lt; this.stus.length)&#123; const result = &#123;value:this.stus[index],done:false&#125; //下标自增 index++; //返回结果 return result; &#125;else&#123; return &#123;value:undefined , done:true&#125; &#125; &#125; &#125; &#125;&#125; 生成器 生成器函数式ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同 声明方式123456789101112131415161718192021function * gen()&#123; console.log(&#x27;hello&#x27;)&#125;let iterator = gen();//console.log(iterator)iterator.next();function * gen()&#123; console.log(111) yield &#x27;嘿嘿嘿&#x27; //yield起到函数代码的分隔符的作用 第一部分 console.log(222) yield &#x27;哈哈哈&#x27; //第二部分 console.log(333) yield &#x27;哦哦哦&#x27; console.log(444)&#125;let iterator = gen();iterator.next(); //输出第一部分111iterator.next(); //输出第二部分222iterator.next(); //输出第三部分333iterator.next(); //输出第四部分444 遍历123456789101112function * gen()&#123; console.log(111) yield &#x27;嘿嘿嘿&#x27; //yield起到函数代码的分隔符的作用 第一部分 console.log(222) yield &#x27;哈哈哈&#x27; //第二部分 console.log(333) yield &#x27;哦哦哦&#x27; console.log(444)&#125;for(let v of gen())&#123; console.log(v);&#125; 生成器函数参数12345678910111213141516function * gen(arg)&#123; console.log(arg) let one = yield 111; console.log(one) let two = yield 222; console.log(two) let three = yield 333; console.log(three)&#125;//执行获取迭代器对象let iterator = gen(&#x27;AAA&#x27;)console.log(iterator.next()) //next方法可以传入实参console.log(iterator.next(&#x27;BBB&#x27;))console.log(iterator.next(&#x27;CCC&#x27;))console.log(iterator.next(&#x27;DDD&#x27;)) 下面为输出结果 生成器函数实例实例一：回调地狱解决问题12345678910111213141516171819202122232425262728293031323334353637//1s后控制台输出111 2s后输出222 3s后输出333//回调地狱// setTimeout(() =&gt; &#123;// console.log(111);// setTimeout(() =&gt; &#123;// console.log(222)// setTimeout(() =&gt; &#123;// console.log(333)// &#125;, 3000);// &#125;, 2000);// &#125;, 1000);function one()&#123;setTimeout(() =&gt; &#123;console.log(111);iterator.next()&#125;, 1000);&#125;function two()&#123;setTimeout(() =&gt; &#123;console.log(222)iterator.next()&#125;, 2000);&#125;function three()&#123;setTimeout(() =&gt; &#123;console.log(333)iterator.next()&#125;, 3000);&#125;function *gen()&#123;yield one()yield two()yield three()&#125;//调用生成器函数let iterator = gen()iterator.next() 实例二1234567891011121314151617181920212223242526272829303132//模拟获取 用户数据 订单数据 商品数据function getUsers()&#123; setTiomeout(()=&gt;&#123; let data = &#x27;用户数据&#x27; //调用next方法，并且将数据传入 iterator.next(data) &#125;,1000)&#125;function getOrders()&#123; setTimeout(()=&gt;&#123; let data = &#x27;订单数据&#x27; iterator.next(data) &#125;,1000)&#125;function getGoods()&#123; setTimeout(()=&gt;&#123; let data = &#x27;商品数据&#x27; iterator.next(data) &#125;,1000)&#125;function * gen()&#123; let users = yield getUsers(); console.log(users) let orders = yield getOrders(); console.log(orders) let goods = yield getGoods(); console.&#125;//调用生成器函数let iterator = gen();iterator.next();","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"}]},{"title":"函数参数默认值设置、reset参数、扩展运算符","slug":"函数参数默认值设置、reset参数、扩展运算符","date":"2021-10-10T01:35:32.000Z","updated":"2021-10-11T08:42:08.468Z","comments":true,"path":"2021/10/10/函数参数默认值设置、reset参数、扩展运算符/","link":"","permalink":"http://daniellin0516.github.io/2021/10/10/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E8%AE%BE%E7%BD%AE%E3%80%81reset%E5%8F%82%E6%95%B0%E3%80%81%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"函数参数的默认值设置1.形参初始值 具有默认值的参数 一般位置要靠后（潜规则）1234567891011function add(a,b,c = 10)&#123; return a + b + c;&#125;let result = add(1,2,3)console.log(result) //输出6function add(a,c = 10，b)&#123; return a + b + c;&#125;let result = add(1,2)console.log(result) //输出NaN 2.与解构赋值结合123456789101112function connect(&#123;host,username,password,port&#125;)&#123; console.log(host) //localhost console.log(username) //root console.log(password) //root console.log(port) //3306&#125;connect(&#123; host: &#x27;localhost&#x27;, username: &#x27;root&#x27;, password: &#x27;root&#x27;, pot: 3306 &#125;) rest参数 ES6引入reset参数，用于获取函数的实参，用来代替arguement ES5获取实参的方式： 1234function date()&#123; console.log(arguement)&#125;date(&#x27;白芷&#x27;,&#x27;阿娇&#x27;) 结果如下图所示 结果是个对象 rest参数1234function date(...args)&#123; console.log(args)&#125;date(&#x27;白芷&#x27;,&#x27;阿娇&#x27;) 结果： 是个数组，可以用数组的方法：filter some every map rest参数必须要放到最后 123456function fn(a,b,...args)&#123; //否则会报错 console.log(a) console.log(b) console.log(args)&#125;fn(1,2,3,4,5,6) 扩展运算符 『…』扩展运算符能将『数组』转换为逗号分隔的『参数序列』 123456789//声明一个数组 ...const tfboys = [&#x27;易烊千玺&#x27;,&#x27;王源&#x27;,&#x27;王俊凯&#x27;]//声明一个函数function chunwan()&#123; console.log(arguments)&#125;chunwan(tfboys) //1chunwan(...tfboys) //2 chuwan(&#x27;易烊千玺&#x27;,&#x27;王源&#x27;,&#x27;王俊凯&#x27;) 1、2的结果如果所示： 扩展运算符的应用1.数组的合并1234const kuaizi = [&#x27;111&#x27;,&#x27;222&#x27;]const fenghuang = [&#x27;333&#x27;,&#x27;444&#x27;]//const xiaopingguo = kuaizi.concat(fenghuang) //ES5const xiaopingguo = [...kuaizi,...fenghuang] 2.数组的克隆12const sanzhihua = [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;]const sannyecao = [...sanzhihua]; //[&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;] 3.将伪数组转为真正的数组123const divs = document.querySelectorAll(&#x27;div&#x27;)const divArr = [...divs]console.log(divArr) //将对象转换为","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"}]},{"title":"变量的解构赋值","slug":"变量的解构赋值","date":"2021-10-09T06:58:41.000Z","updated":"2021-10-09T08:31:13.316Z","comments":true,"path":"2021/10/09/变量的解构赋值/","link":"","permalink":"http://daniellin0516.github.io/2021/10/09/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","excerpt":"","text":"解构ES6允许按照一定模式从数组和对象中提取值，对变量进行复制，这被称为解构赋值 1.数组的解构123456const F4 = [&#x27;11&#x27;,&#x27;22&#x27;,&#x27;33&#x27;,&#x27;44&#x27;]let [xiao,liu,zhao,song] = F4console.log(xiao) //11console.log(liu) //22console.log(zhao) //33console.log(song) //44 2.对象的解构123456789const zhao = &#123; name:&#x27;赵本山&#x27;, age:&#x27;不详&#x27;, xiaopin:function()&#123; console.log(&#x27;我可以演小品&#x27;) &#125;&#125;let &#123;name,age,xiaopin&#125; = zhao 模板字符串 ES6引入新的声明字符串的方式``` ` 1.声明123let str = `我也是字符串`console.log(str,typeof str) //我也是字符串 String 2.内容中可以直接出现换行符123456let str = &#x27;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&#x27; //无法换行let str = `&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;` 3.变量拼接123let lovest = &#x27;魏翔&#x27;let out = `$&#123;lovest&#125;是我心目中最搞笑的演员`console.log(out) //魏翔是我心目中最搞笑的演员 对象的简化方法 ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。 这样的书写更加简洁 1234567891011let name = &#x27;尚硅谷&#x27;let change = function()&#123; console.log(&#x27;我们可以改变&#x27;)&#125;const school = &#123; name, change, improve()&#123; console.log(&quot;我们可以提升你的技能&quot;) &#125;&#125; 箭头函数以及声明特点 ES6允许使用箭头(=&gt;)定义函数 声明一个函数 123456789let fn = function()&#123; &#125;let fn = (a,b)=&gt;&#123; return a+b&#125;//调用函数let result = fn(1,2)console.log(result) //3 1.this是静态的，this始终指向函数声明时所在作用域下的this的值123456789101112131415161718function getName()&#123; console.log(this.name)&#125;let getName2 = () =&gt;&#123; console.log(this.name)&#125;//设置window对象的name属性window.name = &#x27;尚硅谷&#x27;const school = &#123; name:&#x27;ATGUIGU&#x27;&#125;//直接调用getName(); 尚硅谷getName2(); 尚硅谷 //call方法调用getName.call(school) //ATGUIGUgetName2.call(school) //尚硅谷 2.不能作为构造实例化对象123456let Person = (name,age) =&gt;&#123; this.name = name this.age = age&#125;let me = New Person(&#x27;xiao&#x27;,30);console.log(me) //报错 3.不能使用arguments变量1234let fn = ()=&gt;&#123; console.log(arguements)&#125;fn(1,2,3) //报错 4.箭头函数的简写 省略小括号，当形参有且只有一个的时候 1234let add = n =&gt;&#123; return n+n&#125;console.log(add(9)) //18 省略花括号，当代码体只有一条语句的时候，此时return必须省略 而且语句的执行结果就是函数的返回值 12let pow = (n)=&gt; n *nconsole.log(pow(9)) //81","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"}]},{"title":"块级作用域绑定","slug":"块级作用域绑定","date":"2021-10-09T02:29:00.000Z","updated":"2021-10-09T09:08:49.131Z","comments":true,"path":"2021/10/09/块级作用域绑定/","link":"","permalink":"http://daniellin0516.github.io/2021/10/09/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A/","excerpt":"","text":"let声明声明变量 1234let a;let b,c,d;let e = 100;let f = 521 , g = &#x27;Iloveyou&#x27; 1.变量不能重复声明12let star = &#x27;罗志祥&#x27;let star = &#x27;小猪&#x27; 2.块级作用域全局，函数，eval if else while for 1234&#123; let girl = &#x27;周扬青&#x27;&#125;console.log(girl) //undefined 1234&#123; var girl = &#x27;周扬青&#x27;&#125;console.log(girl) //周扬青 3.不存在变量提升1234&#123; console.log(song) var song = &#x27;9999&#x27; //不会报错，会显示undefined&#125; 1234&#123; console.log(song) let song = &#x27;8999&#x27; //报错，无提升&#125; 4.不影响作用域链1234567&#123; let school = &#x27;尚硅谷&#x27; function fn()&#123; console.log(school) &#125; fn(); //输出尚硅谷&#125; const 定义常量声明常量 12const scool = &#x27;山硅谷&#x27;console.log(school) 1.一定要赋初始值1const A //报错，未赋予初始值 2.一般常量使用大写（潜规则）1const a = 100 3.常量的值不能修改12const scool = &#x27;山硅谷&#x27;school = &#x27;aaaa&#x27; //报错 4.块级作用域1234&#123; const Player = &#x27;uzi&#x27;&#125;console.log(Player) //报错 5.对于数组和对象的元素修改，不算做对常量的修改，不会报错12const Tanm = [&#x27;uzi&#x27;,&#x27;mxlg&#x27;]Tanm.push(&#x27;M&#x27;)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"}]},{"title":"树（入门）","slug":"树（入门）","date":"2021-09-28T10:50:12.000Z","updated":"2021-10-02T13:28:26.413Z","comments":true,"path":"2021/09/28/树（入门）/","link":"","permalink":"http://daniellin0516.github.io/2021/09/28/%E6%A0%91%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"","text":"树1.二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 思路：递归和迭代，前序遍历为中-左-右 递归 12345678910111213var preorderTraversal = function(root) &#123; if (!root) return [] const res = [] preorder(root, res) return res&#125;var preorder = function(node, res) &#123; if (!node) return res.push(node.val) preorder(node.left, res) preorder(node.right, res)&#125; 迭代 12345678910111213var preorderTraversal = function(root) &#123; if (!root) return [] const stack = [], res = [] stack.push(root) while (stack.length) &#123; const curr = stack.pop() res.push(curr.val) if (curr.right) stack.push(curr.right) if (curr.left) stack.push(curr.left) &#125; return res&#125;; 2.二叉树的中序遍历给定一个二叉树的根节点 root ，返回它的 中序 遍历。 思路： 迭代和递归，中序的顺序：左-中-右 迭代 1234567891011121314var inorderTraversal = function(root) &#123; const res = []; const stk = []; while (root || stk.length) &#123; while (root) &#123; stk.push(root); root = root.left; &#125; root = stk.pop(); res.push(root.val); root = root.right; &#125; return res;&#125;; 递归 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function(root) &#123;const res = []const inorder = (root) =&gt;&#123; if(!root)&#123; return &#125; inorder(root.left) res.push(root.val) inorder(root.right)&#125;inorder(root)return res&#125;; 3.二叉树的后序遍历给定一个二叉树，返回它的 后序 遍历。 思路：迭代和递归 12345678910111213141516var postorderTraversal = function(root) &#123; let result = []; this.postOrder = function(root) &#123; if (root == null) &#123; return; &#125; postOrder(root.left); postOrder(root.right); // 后序遍历位置 result.push(root.val); &#125; postOrder(root); return result;&#125;; 4.二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。（即逐层地，从左到右访问所有节点）。 123456789101112131415161718192021222324var levelOrder = function(root) &#123; //二叉树的层序遍历 let res=[],queue=[]; queue.push(root); if(root===null)&#123; return res; &#125; while(queue.length!==0)&#123; // 记录当前层级节点数 let length=queue.length; //存放每一层的节点 let curLevel=[]; for(let i=0;i&lt;length;i++)&#123; let node=queue.shift(); curLevel.push(node.val); // 存放当前层下一层的节点 node.left&amp;&amp;queue.push(node.left); node.right&amp;&amp;queue.push(node.right); &#125; //把每一层的结果放到结果数组 res.push(curLevel); &#125; return res;&#125;; 5.二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 123456789var maxDepth = function(root) &#123; if(!root) &#123; return 0; &#125; else &#123; const left = maxDepth(root.left); const right = maxDepth(root.right); return Math.max(left, right) + 1; &#125;&#125;; 6.对称二叉树 12345678910111213141516171819202122var isSymmetric = function(root) &#123; //使用递归遍历左右子树 递归三部曲 // 1. 确定递归的参数 root.left root.right和返回值true false const compareNode=function(left,right)&#123; //2. 确定终止条件 空的情况 if(left===null&amp;&amp;right!==null||left!==null&amp;&amp;right===null)&#123; return false; &#125;else if(left===null&amp;&amp;right===null)&#123; return true; &#125;else if(left.val!==right.val)&#123; return false; &#125; //3. 确定单层递归逻辑 let outSide=compareNode(left.left,right.right); let inSide=compareNode(left.right,right.left); return outSide&amp;&amp;inSide; &#125; if(root===null)&#123; return true; &#125; return compareNode(root.left,root.right);&#125;; 7.翻转二叉树翻转一棵二叉树。 12345678910var invertTree = function(root) &#123; if (root === null) &#123; return null; &#125; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root;&#125;; 8.路径总和给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。 叶子节点 是指没有子节点的节点。 123456789var hasPathSum = function(root, targetSum) &#123; // 节点不存在 返回false if(!root) return false // 左右子树都不存在，说明是叶子节点，判断是否符合条件 if(!root.left &amp;&amp; !root.right) return targetSum === root.val // 到这里就是：节点存在，左右子树存在一个或者都存在，也就是内部节点 // 遍历左右子树，更新总和为 总和删除当前节点的值 return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)&#125;; 9.二叉搜索树中的搜索给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如， 思路： 递归和迭代 递归： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; val * @return &#123;TreeNode&#125; */var searchBST = function (root, val) &#123; if (!root || root.val === val) &#123; return root; &#125; if (root.val &gt; val) return searchBST(root.left, val); if (root.val &lt; val) return searchBST(root.right, val); return null;&#125;; 迭代： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; val * @return &#123;TreeNode&#125; */var searchBST = function (root, val) &#123; while (root !== null) &#123; if (root.val &gt; val) root = root.left; else if (root.val &lt; val) root = root.right; else return root; &#125; return root;&#125;; 10.二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回**任意有效的结果 **。 思路： 因此，当将val 插入到以root 为根的子树上时，根据 val 与root.val 的大小关系，就可以确定要将 val 插入到哪个子树中。 如果该子树不为空，则问题转化成了将val 插入到对应子树上。否则，在此处新建一个以val 为值的节点，并链接到其父节点root 上。 12345678910111213141516171819202122232425var insertIntoBST = function(root, val) &#123; if (root === null) &#123; return new TreeNode(val); &#125; let pos = root; while (pos !== null) &#123; if (val &lt; pos.val) &#123; if (pos.left === null) &#123; pos.left = new TreeNode(val); break; &#125; else &#123; pos = pos.left; &#125; &#125; else &#123; if (pos.right === null) &#123; pos.right = new TreeNode(val); break; &#125; else &#123; pos = pos.right; &#125; &#125; &#125; return root;&#125;; 11.验证二叉搜索树给你一个二叉树的根节点root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 思路： 要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。 123456789101112const helper = (root, lower, upper) =&gt; &#123; if (root === null) &#123; return true; &#125; if (root.val &lt;= lower || root.val &gt;= upper) &#123; return false; &#125; return helper(root.left, lower, root.val) &amp;&amp; helper(root.right, root.val, upper);&#125;var isValidBST = function(root) &#123; return helper(root, -Infinity, Infinity);&#125;; 12.两数之和IV-输入BST给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 思路： 哈希表，迭代法，前序遍历 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; k * @return &#123;boolean&#125; */var findTarget = function(root, k) &#123; let myMap = new Map() let queue = [] if(!root)&#123; return false &#125; queue.push(root) while(queue.length)&#123; let i=0 let curNode = queue.pop() deffer = k - curNode.val if(myMap.has(deffer))&#123; return true &#125; myMap.set(curNode.val,i) if(curNode.left !=null)&#123; queue.push(curNode.left) &#125; if(curNode.right !=null)&#123; queue.push(curNode.right) &#125; i++ &#125; return false&#125;; 13.二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 12345678910111213141516171819var lowestCommonAncestor = function(root, p, q) &#123; // 使用递归的方法 // 1. 使用给定的递归函数lowestCommonAncestor // 2. 确定递归终止条件 if(root === null) &#123; return root; &#125; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) &#123; // 向左子树查询 let left = lowestCommonAncestor(root.left,p,q); return left !== null&amp;&amp;left; &#125; if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) &#123; // 向右子树查询 let right = lowestCommonAncestor(root.right,p,q); return right !== null&amp;&amp;right; &#125; return root;&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"栈/队列（入门）","slug":"栈-队列（入门）","date":"2021-09-27T02:59:22.000Z","updated":"2021-09-27T03:08:40.200Z","comments":true,"path":"2021/09/27/栈-队列（入门）/","link":"","permalink":"http://daniellin0516.github.io/2021/09/27/%E6%A0%88-%E9%98%9F%E5%88%97%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"","text":"栈/队列1.有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 思路：利用栈的先进后出，匹配后将元素出栈，若栈还有元素则返回false 123456789101112131415161718192021222324var isValid = function(s) &#123; const n = s.length; if (n % 2 === 1) &#123; return false; &#125; const pairs = new Map([ [&#x27;)&#x27;, &#x27;(&#x27;], [&#x27;]&#x27;, &#x27;[&#x27;], [&#x27;&#125;&#x27;, &#x27;&#123;&#x27;] ]); const stk = []; for (let ch of s)&#123; if (pairs.has(ch)) &#123; if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) &#123; return false; &#125; stk.pop(); &#125; else &#123; stk.push(ch); &#125; &#125;; return !stk.length;&#125;; 2.用栈实现队列请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一 一个栈，只要是标准的栈操作即可。 思路：利用辅助栈 123456789101112131415161718192021222324252627282930313233var MyQueue = function() &#123; this.inStack = []; this.outStack = [];&#125;;MyQueue.prototype.push = function(x) &#123; this.inStack.push(x);&#125;;MyQueue.prototype.pop = function() &#123; if (!this.outStack.length) &#123; this.in2out(); &#125; return this.outStack.pop();&#125;;MyQueue.prototype.peek = function() &#123; if (!this.outStack.length) &#123; this.in2out(); &#125; return this.outStack[this.outStack.length - 1];&#125;;MyQueue.prototype.empty = function() &#123; return this.outStack.length === 0 &amp;&amp; this.inStack.length === 0;&#125;;MyQueue.prototype.in2out = function() &#123; while (this.inStack.length) &#123; this.outStack.push(this.inStack.pop()); &#125;&#125;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"链表（入门）","slug":"链表（入门）","date":"2021-09-25T12:21:19.000Z","updated":"2021-09-26T07:14:55.015Z","comments":true,"path":"2021/09/25/链表（入门）/","link":"","permalink":"http://daniellin0516.github.io/2021/09/25/%E9%93%BE%E8%A1%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"","text":"链表1.环形链表给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 思路： 哈希表： 利用键值对记得每个元素有无记录如果有的话就返回false 快慢指针： 快、慢指针，从头节点出发慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值如果节点值相同，说明有环。如果不同，继续循环。类似 “追及问题”两个人在环形跑道上赛跑，同一个起点出发，一个跑得快一个跑得慢，在某一时刻，跑得快的必定会追上跑得慢的，只要是跑道是环形的，不是环形就肯定追不上。 哈希表 12345678910var hasCycle = (head) =&gt; &#123; let map = new Map(); while (head) &#123; if (map.has(head)) return true; map.set(head, true); // 存的是节点的地址引用，而不是节点值 head = head.next; &#125; return false;&#125;; 快慢指针 1234567891011var hasCycle = (head) =&gt; &#123; let fast = head; let slow = head; while (fast) &#123; if (fast.next == null) return false; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false; &#125; 2.合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 思路： 递归： 我们直接将以上递归过程建模，同时需要考虑边界情况。 如果 l1或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。 迭代： 通过设置一个哑结点 首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到l1或者l2指向了 null ：如果 l1 当前节点的值小于等于l2，我们就把l1当前的节点接在 prev 节点的后面同时将l1指针往后移一位。否则，我们对l2做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。 在循环终止的时候，l1和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。 递归 12345678910111213var mergeTwoLists = function(l1, l2) &#123; if (l1 === null) &#123; return l2; &#125; else if (l2 === null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;; 迭代 1234567891011121314151617181920var mergeTwoLists = function(l1, l2) &#123; const prehead = new ListNode(-1); let prev = prehead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可 prev.next = l1 === null ? l2 : l1; return prehead.next;&#125;; 3.移除链表元素给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 思路：因为不知道头结点是否会和val值相等，所以要设置一个哑结点，迭代删除 12345678910111213var removeElements = function(head, val) &#123; const dummyHead = new ListNode(0); dummyHead.next = head; let temp = dummyHead; while (temp.next !== null) &#123; if (temp.next.val == val) &#123; temp.next = temp.next.next; &#125; else &#123; temp = temp.next; &#125; &#125; return dummyHead.next;&#125;; 4.反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 思路： 在遍历链表时，将当前节点的next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。 1234567891011var reverseList = function(head) &#123; let prev = null; let curr = head; while (curr) &#123; const next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev;&#125;; 5.删除排序链表中的重复元素存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 思路： 123456789101112131415var deleteDuplicates = function(head) &#123; if (!head) &#123; return head; &#125; let cur = head; while (cur.next) &#123; if (cur.val === cur.next.val) &#123; cur.next = cur.next.next; &#125; else &#123; cur = cur.next; &#125; &#125; return head;&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"字符串(入门)","slug":"字符串-入门","date":"2021-09-24T08:28:38.000Z","updated":"2021-09-24T08:43:43.613Z","comments":true,"path":"2021/09/24/字符串-入门/","link":"","permalink":"http://daniellin0516.github.io/2021/09/24/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%85%A5%E9%97%A8/","excerpt":"","text":"数组专题1.字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 方法：队列思路与算法 我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。 具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 cc，如果 cc 不在哈希映射中，我们就将 cc 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 -1−1）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。 在遍历完成后，如果队列为空，说明没有不重复的字符，返回 -1−1，否则队首的元素即为第一个不重复的字符以及其索引的二元组。 123456789101112131415161718192021var firstUniqChar = function(s) &#123; const position = new Map(); const n = s.length; for (let [i, ch] of Array.from(s).entries()) &#123; if (position.has(ch)) &#123; position.set(ch, -1); &#125; else &#123; position.set(ch, i); &#125; &#125; let first = n; for (let pos of position.values()) &#123; if (pos !== -1 &amp;&amp; pos &lt; first) &#123; first = pos; &#125; &#125; if (first === n) &#123; first = -1; &#125; return first;&#125;; 2.赎金信给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 思路： 因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。 然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。 依然是数组在哈希法中的应用。 一些同学可能想，用数组干啥，都用map完事了，其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！ 12345678910111213141516171819/** * @param &#123;string&#125; ransomNote * @param &#123;string&#125; magazine * @return &#123;boolean&#125; */var canConstruct = function(ransomNote, magazine) &#123; const strArr = new Array(26).fill(0), base = &quot;a&quot;.charCodeAt(); for(const s of magazine) &#123; strArr[s.charCodeAt() - base]++; &#125; for(const s of ransomNote) &#123; const index = s.charCodeAt() - base; if(!strArr[index]) return false; strArr[index]--; &#125; return true;&#125;; 3.有效的字母异位词给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 思路：哈希表从另一个角度考虑，t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含26个小写字母，因此我们可以维护一个长度为26的频次数组 table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去 table 中对应的频次，如果出现table[i]&lt;0，则说明 t 包含一个不在 s 中的额外字符，返回 false 即可。 12345678910111213141516var isAnagram = function(s, t) &#123; if (s.length !== t.length) &#123; return false; &#125; const table = new Array(26).fill(0); for (let i = 0; i &lt; s.length; ++i) &#123; table[s.codePointAt(i) - &#x27;a&#x27;.codePointAt(0)]++; &#125; for (let i = 0; i &lt; t.length; ++i) &#123; table[t.codePointAt(i) - &#x27;a&#x27;.codePointAt(0)]--; if (table[t.codePointAt(i) - &#x27;a&#x27;.codePointAt(0)] &lt; 0) &#123; return false; &#125; &#125; return true;&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"Git_Githhb推送本地库到远程库","slug":"Git-Githhb推送本地库到远程库","date":"2021-09-23T08:15:01.000Z","updated":"2021-09-23T08:37:38.833Z","comments":true,"path":"2021/09/23/Git-Githhb推送本地库到远程库/","link":"","permalink":"http://daniellin0516.github.io/2021/09/23/Git-Githhb%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%BA%93/","excerpt":"","text":"推送本地库到远程库基本语法git push别名 分支 git checkout master 是切换成master分支 实例1git push xxx(如果没有别名可以不写) master 拉取远程库到本地库基本语法git pull 别名 分支 克隆远程仓库到本地 语法git clone https://xxxxx.git clone会做如下操作： 1.拉取代码 2.初始化本地仓库 3.创建别名","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://daniellin0516.github.io/tags/Git/"}]},{"title":"Git_Github创建远程库&创建别名","slug":"Git-Github创建远程库-创建别名","date":"2021-09-23T07:57:17.000Z","updated":"2021-09-23T08:11:20.469Z","comments":true,"path":"2021/09/23/Git-Github创建远程库-创建别名/","link":"","permalink":"http://daniellin0516.github.io/2021/09/23/Git-Github%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%BA%93-%E5%88%9B%E5%BB%BA%E5%88%AB%E5%90%8D/","excerpt":"","text":"创建远程仓库 创建远程仓库别名基本语法git remote -v 查看当前所有远程地址别名 git remote add 别名 远程地址 123git remote -vgit reomote add xxxx https://xxxx.gitgit remote -v","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://daniellin0516.github.io/tags/Git/"}]},{"title":"数组专题（入门）","slug":"数组专题（入门）","date":"2021-09-19T02:42:30.000Z","updated":"2021-09-23T06:56:45.555Z","comments":true,"path":"2021/09/19/数组专题（入门）/","link":"","permalink":"http://daniellin0516.github.io/2021/09/19/%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"","text":"数组1.存在重复元素给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 思路：先将数组按大小排好，利用sort()，然后在相邻之间进行比较是否要相同元素 12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var containsDuplicate = function(nums) &#123; nums.sort((a,b)=&gt;b-a); for(var i=0; i &lt; nums.length ; i++)&#123; if(nums[i] == nums[i+1])&#123; return true; &#125; &#125; return false; &#125; 2.最大子序和（动态规划）给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 思路： 这种方法称作正数增益，这样子就可以找到最大的和 12345678910111213var maxSubArray = function(nums) &#123; let ans = nums[0]; let sum = 0; for(const num of nums) &#123; if(sum &gt; 0) &#123; sum += num; &#125; else &#123; sum = num; &#125; ans = Math.max(ans, sum); &#125; return ans;&#125;; 3.两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 思路：暴力解法，哈希表 1234567891011121314/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123;for(let i = 0;i&lt;nums.length-1;i++)&#123; for(let j = i+1; j &lt; nums.length ; j++)&#123; if(nums[i]+nums[j]==target)&#123; return [i,j] &#125; &#125;&#125;&#125;; 4.合并两个有序数组给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到nums1中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 思路：利用splice将sums1的替代元素删除并加上sums2 12345var merge = function(nums1, m, nums2, n) &#123; nums1.splice(m, nums1.length - m, ...nums2); nums1.sort((a, b) =&gt; a - b);&#125;; 方法二：双指针法 123456789101112131415161718192021var merge = function(nums1, m, nums2, n) &#123; let p1 = 0, p2 = 0; const sorted = new Array(m + n).fill(0); var cur; while (p1 &lt; m || p2 &lt; n) &#123; if (p1 === m) &#123; cur = nums2[p2++]; &#125; else if (p2 === n) &#123; cur = nums1[p1++]; &#125; else if (nums1[p1] &lt; nums2[p2]) &#123; cur = nums1[p1++]; &#125; else &#123; cur = nums2[p2++]; &#125; sorted[p1 + p2 - 1] = cur; &#125; for (let i = 0; i != m + n; ++i) &#123; nums1[i] = sorted[i]; &#125;&#125;; 5.两个数组的交集给定两个数组，编写一个函数来计算它们的交集。 思路：利用双指针进行做题 12345678910111213let intersect = function (nums1, nums2) &#123; nums1.sort((a, b) =&gt; a - b); nums2.sort((a, b) =&gt; a - b); let l = 0, r = 0, ans = []; while (l &lt; nums1.length &amp;&amp; r &lt; nums2.length) &#123; if (nums1[l] === nums2[r]) &#123; ans.push(nums1[l]); l++; r++; &#125; else nums1[l] &lt; nums2[r] ? l++ : r++; &#125; return ans;&#125;; 6.买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 思路一：暴力解法（该方法超时了） 123456789101112131415161718192021/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; var max = 0; for(let i = 0 ; i &lt; prices.length-1 ; i++)&#123; for(let j = i+1 ; j &lt; prices.length ; j++)&#123; const profit = prices[j] - prices[i]; if(profit &gt; max)&#123; max = profit; &#125; &#125; &#125; if(max &lt; 0)&#123; return 0; &#125;else&#123; return max; &#125;&#125; 思路二：贪心算法 123456789101112131415const maxProfit = prices =&gt; &#123; // 先定义第一天为最低价格 let min = prices[0]; // 利润 let profit = 0; // 遍历数据 for (let i = 1; i &lt; prices.length; i++) &#123; // 如果发现比最低价格还低的，更新最低价格 min = Math.min(min, prices[i]); // 如果发现当前利润比之前高的，更新利润 profit = Math.max(profit, prices[i] - min); &#125; return profit;&#125;; 7.重塑矩阵在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 思路： 重塑矩阵 - 重塑矩阵 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314var matrixReshape = function(nums, r, c) &#123; const m = nums.length; const n = nums[0].length; if (m * n != r * c) &#123; return nums; &#125; const ans = new Array(r).fill(0).map(() =&gt; new Array(c).fill(0)); for (let x = 0; x &lt; m * n; ++x) &#123; ans[Math.floor(x / c)][x % c] = nums[Math.floor(x / n)][x % n]; &#125; return ans;&#125;; 8.杨辉三角给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 123456789101112var generate = function(numRows) &#123; const ret = []; for (let i = 0; i &lt; numRows; i++) &#123; const row = new Array(i + 1).fill(1); for (let j = 1; j &lt; row.length - 1; j++) &#123; row[j] = ret[i - 1][j - 1] + ret[i - 1][j]; &#125; ret.push(row); &#125; return ret;&#125;; 9.有效的数独请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 注意： 一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。 1234567891011121314151617181920212223const isValidSudoku = board =&gt; &#123; // 三个方向判重 const [rows, columns, boxes] = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 遍历数独 for (let i = 0; i &lt; 9; i++) &#123; for (let j = 0; j &lt; 9; j++) &#123; const num = board[i][j]; if (num !== &#x27;.&#x27;) &#123; // 子数独序号:0~8，一共9个 const boxIndex = parseInt(i / 3) * 3 + parseInt(j / 3); // 如果当前数已经在某个位置出现过了，返回false if (rows[i + &#x27;-&#x27; + num] || columns[j + &#x27;-&#x27; + num] || boxes[boxIndex + &#x27;-&#x27; + num]) &#123; return false; &#125; // 三个方向上每个位置，将当前数做标记，表示出现过了 rows[i + &#x27;-&#x27; + num] = true; columns[j + &#x27;-&#x27; + num] = true; boxes[boxIndex + &#x27;-&#x27; + num] = true; &#125; &#125; &#125; return true;&#125;; 10.矩阵置零给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 进阶： 一个直观的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。你能想出一个仅使用常量空间的解决方案吗？ 思路： 标记数组，我们可以用两个标记数组分别记录每一行和每一列是否有零出现。 具体地，我们首先遍历该数组一次，如果某个元素为 00，那么就将该元素所在的行和列所对应标记数组的位置置为 true。最后我们再次遍历该数组，用标记数组更新原数组即可。 1234567891011121314151617181920var setZeroes = function(matrix) &#123; const m = matrix.length, n = matrix[0].length; const row = new Array(m).fill(false); const col = new Array(n).fill(false); for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (matrix[i][j] === 0) &#123; row[i] = col[j] = true; &#125; &#125; &#125; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (row[i] || col[j]) &#123; matrix[i][j] = 0; &#125; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"替换空格（字符串数组）","slug":"替换空格（字符串数组）","date":"2021-09-17T03:13:30.000Z","updated":"2021-09-17T03:34:36.453Z","comments":true,"path":"2021/09/17/替换空格（字符串数组）/","link":"","permalink":"http://daniellin0516.github.io/2021/09/17/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%EF%BC%89/","excerpt":"","text":"替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 思路一：利用字符串拼接(不推荐，因为 JS中字符串无法被修改，一旦给字符串变量重新赋值，就要花费时间和空间去重新新建一个字符串，从而增加了复杂度！) 12345678910111213141516/** * @param &#123;string&#125; s * @return &#123;string&#125; */var replaceSpace = function(s) &#123;var res = &#x27;&#x27;;for(var i = 0 ; i &lt; s.length ; i++)&#123; var ch = s[i]; if(s[i]==&#x27; &#x27;)&#123; res += &quot;%20&quot; ; &#125;else&#123; res = res + ch; &#125;&#125;return res;&#125;; 思路二： 将字符串转换为数组，然后统计其中的空格数量。 根据空格数量和原有字符串有效字符长度，计算出刚好存放替换后的字符长度的数组。 创建两个指针，一个指数组末尾，一个指字符串有效位的末尾，实现原地修改. 12345678910111213141516171819202122232425/** * @param &#123;string&#125; s * @return &#123;string&#125; */var replaceSpace = function(s) &#123; s = s.split(&quot;&quot;); let oldLen = s.length; let spaceCount = 0; for (let i = 0; i &lt; oldLen; i++) &#123; if (s[i] === &#x27; &#x27;) spaceCount++; &#125; s.length += spaceCount * 2; for (let i = oldLen - 1, j = s.length - 1; i &gt;= 0; i--, j--) &#123; if (s[i] !== &#x27; &#x27;) s[j] = s[i]; else &#123; s[j - 2] = &#x27;%&#x27;; s[j - 1] = &#x27;2&#x27;; s[j] = &#x27;0&#x27;; j -= 2; &#125; &#125; return s.join(&#x27;&#x27;);&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"包含min函数的栈","slug":"包含min函数的栈","date":"2021-09-15T04:19:52.000Z","updated":"2021-09-15T04:58:08.860Z","comments":true,"path":"2021/09/15/包含min函数的栈/","link":"","permalink":"http://daniellin0516.github.io/2021/09/15/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","excerpt":"","text":"包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 主要思路：利用两个栈 ，stack负责出栈入栈，另外一个作为辅助栈min_stack存储stack中的最小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * initialize your data structure here. */var MinStack = function() &#123;this.stack = [];this.minstack = [Infinity];&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.stack.push(x); this.minstack.push(Math.min(this.minstack[this.minstack.length - 1],x)); &#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123;this.stack.pop();this.minstack.pop();&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123;return this.stack[this.stack.length-1]; &#125;;/** * @return &#123;number&#125; */MinStack.prototype.min = function() &#123;return this.minstack[this.minstack.length-1];&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.min() */","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"用两个栈实现队列","slug":"用两个栈实现队列","date":"2021-09-14T10:19:08.000Z","updated":"2021-09-14T10:38:20.879Z","comments":true,"path":"2021/09/14/用两个栈实现队列/","link":"","permalink":"http://daniellin0516.github.io/2021/09/14/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 123456789101112131415161718192021222324252627282930var CQueue = function() &#123; this.stackA = []; //创建栈 this.stackB = []; //创建栈&#125;;/** * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123; this.stackA.push(value); //将栈A设为入队栈&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123; if(this.stackB.length)&#123; //判断栈B是否为空栈 return this.stackB.pop(); //将栈B的顶部移出（也就是A的入队元素移出） &#125;else&#123; while(this.stackA.length)&#123; this.stackB.push(this.stackA.pop()); //将A的栈顶元素推入栈底 &#125; if(!this.stackB.length)&#123; return -1; //若B为空栈返回-1 &#125;else&#123; return this.stackB.pop(); //返回B出栈元素 &#125; &#125;&#125;;","categories":[],"tags":[{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"跨域","slug":"跨域","date":"2021-09-12T08:50:12.000Z","updated":"2021-09-12T11:32:41.635Z","comments":true,"path":"2021/09/12/跨域/","link":"","permalink":"http://daniellin0516.github.io/2021/09/12/%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"同源策略同源策略最早由NETscape公司提出，是浏览器一种安全策略。 同源：协议、域名、端口号 必须完全相同 违背同源策略就是跨域 123456789101112131415const btn = document.querySelector(&quot;button&quot;); btn.onclick = function()&#123; const x = new XMLHttpRequest(); //这里因为是满足同源策略的,所以url可以简写 x.open(&quot;GET&quot;,&quot;/data&quot;); //发送 x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; if(x.status &gt;=200 &amp;&amp; x.status &lt; 300)&#123; console.log(x.response); &#125; &#125; &#125; &#125; 服务器后端 123456789101112const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/home&#x27;,(request,response)=&gt;&#123; //响应一个页面 response.sendFile(__dirname + &quot;/index.html&quot;);&#125;);app.get(&#x27;/data&#x27;,(request,response)=&gt;&#123; response.send(&quot;用户数据&quot;);&#125;);app.listen(9000,()=&gt;&#123; console.log(&quot;服务已经启动……&quot;);&#125;); 如何解决跨域1.JSONPJSONP是一个非官方的跨域解决方案，只支持get请求 通过script标签实现跨域 123456789&lt;script&gt; function handle(data)&#123; //获取 result元素 const result = document.getElementById(&quot;result&quot;); result.innerHTML = data.name;&#125; &lt;/script&gt; &lt;!-- &lt;script src=&quot;./js/app.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;http://127.0.0.1:8000/jsonp-server&quot;&gt;&lt;/script&gt; 后端js代码： 12345678910app.all(&#x27;/jsonp-server&#x27;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;helllo&quot;)&#x27;); //返回必须是js代码 const data = &#123; name:&quot;山硅谷&quot; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;) 原生JSONP实践 123456789101112131415161718192021222324252627&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; //获取input元素 const input = document.querySelector(&quot;input&quot;); const p = document.querySelector(&quot;p&quot;); //声明handle函数 function handle(data)&#123; input.style.border = &quot;solid 1px #f00&quot;; //修改p标签的提示文本 p.innerHTML = data.msg; &#125;; //绑定实践 input.onblur = function()&#123; //获取用户输入值 let username = this.value; //向服务器发送请求 检测用户名是否存在 //创建script标签 const script = document.createElement(&quot;script&quot;); //2.设置标签的src属性 script.src = &quot;http://127.0.0.1:8000/check-username&quot;; //3.将script插入到文档中 document.body.appendChild(script); &#125;; &lt;/script&gt;&lt;/body&gt; 后端JS 1234567891011app.all(&#x27;/check-username&#x27;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;helllo&quot;)&#x27;); //返回必须是js代码 const data = &#123; exist: 1, msg: &quot;用户名已经存在&quot; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;) JQuery发送jsonp请求12345678910111213141516&lt;body&gt; &lt;button&gt;点击发送jsonp请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; $(&quot;button&quot;).eq(0).click(function()&#123; $.getJSON(&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;,function(data)&#123; $(&quot;result&quot;).html(` 名称: $&#123;data.name&#125;&lt;br&gt; 校区: $&#123;data.city&#125; `) &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 1234567891011121314app.all(&#x27;/jquery-jsonp-server&#x27;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;helllo&quot;)&#x27;); //返回必须是js代码 const data = &#123; name:&quot;尚硅谷&quot;, city: [&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收callback参数 let cb = request.query.callback; //返回结果 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;) CORS跨域资源共享，cors是官方的跨域解决方案，它的特点是不需要在客户端任何特殊的操作，完全在服务期进行处理，支持get和post请求。 12345678910111213const btn = document.querySelector(&quot;button&quot;); btn.onclick = function()&#123; const x = new XMLHttpRequest(); x.open(&quot;GET&quot;,&quot;http://127.0.0.1:8000/cors-server&quot;); x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; if(x.status &gt;=200 &amp;&amp; x.status &lt; 300)&#123; console.log(x.response); &#125; &#125; &#125; &#125; 12345app.all(&#x27;/cors-server&#x27;,(request,response)=&gt;&#123; response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); // response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://127.0.0.1:5500&#x27;); response.send(&quot;hello cors&quot;);&#125;)","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"JQuery发送AJAX","slug":"JQuery发送AJAX","date":"2021-09-11T07:52:01.000Z","updated":"2021-09-11T10:58:47.889Z","comments":true,"path":"2021/09/11/JQuery发送AJAX/","link":"","permalink":"http://daniellin0516.github.io/2021/09/11/JQuery%E5%8F%91%E9%80%81AJAX/","excerpt":"","text":"JQuery发送AJAX请求GET请求12345$(&quot;button&quot;).eq(0).click(function()&#123; $.get(&quot;http://127.0.0.1:8000/jquery-server&quot;, &#123;a:100,b:200&#125;,function(data)&#123; console.log(data); &#125;,&#x27;json&#x27;); &#125;); POST请求12345$(&quot;button&quot;).eq(1).click(function()&#123; $.post(&quot;http://127.0.0.1:8000/jquery-server&quot;, &#123;a:100,b:200&#125;,function(data)&#123; console.log(data); &#125;); &#125;); 服务器后端设置： 123456app.all(&#x27;/jquery-server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); const data = &#123;name: &#x27;尚硅谷&#x27;&#125;; response.send(JSON.stringify(data));&#125;); 通用型方法AJAX123456789101112131415161718192021222324252627$(&quot;button&quot;).eq(2).click(function()&#123; $.ajax(&#123; //url url:&#x27;http://127.0.0.1:8000/jquery-server&#x27;, //参数 data:&#123;a:100,b:200&#125;, //请求类型 type:&#x27;GET&#x27;, //响应体结果 dataType:&#x27;json&#x27;, //成功的回调 success:function(data)&#123; console.log(data); &#125;, //超时时间 timeout: 2000, //失败的回调 error:function()&#123; console.log(&quot;出错啦！&quot;); &#125;, //头信息 headers:&#123; c:300, d:400 &#125; &#125;); &#125;); Axios发送Ajax请求GET请求1234567891011121314151617btns[0].onclick = function()&#123; //GET请求 axios.get(&quot;/axios-server&quot;,&#123; //url参数 params:&#123; id:100, vip:7, &#125;, //请求头信息 headers: &#123; name:&#x27;atguigu&#x27;, age:20 &#125; &#125;).then(value =&gt; &#123; console.log(value); &#125;); &#125;; POST请求1234567891011121314151617btns[1].onclick = function()&#123; axios.post(&quot;/axios-server&quot;,&#123; username:&quot;admin&quot;, password:&#x27;admin&#x27; &#125;,&#123; //url params: &#123; id:200, vip:9 &#125;, //请求头参数 headers: &#123; height:180, weight:180, &#125; &#125;); &#125; 通用型方法AJAX1234567891011121314151617181920212223242526272829303132btns[2].onclick = function()&#123; axios(&#123; //请求方法 method:&quot;POST&quot;, //url url:&quot;/axios-server&quot;, //url参数 params:&#123; vip:10, level:30 &#125;, headers:&#123; a:100, b:200 &#125;, //请求体参数 data:&#123; username:&quot;admin&quot;, password:&quot;admin&quot; &#125; &#125;).then(response=&gt;&#123; console.log(response); //响应状态码 console.log(response.status); //响应状态字符串 console.log(statusText); //响应头信息 console.log(response.headers); //响应体 console.log(response.data); &#125;) &#125;;","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"AJAX超时请求、取消请求、重复发送请求","slug":"AJAX超时请求、取消请求、重复发送请求","date":"2021-09-11T01:46:57.000Z","updated":"2021-09-11T02:21:53.436Z","comments":true,"path":"2021/09/11/AJAX超时请求、取消请求、重复发送请求/","link":"","permalink":"http://daniellin0516.github.io/2021/09/11/AJAX%E8%B6%85%E6%97%B6%E8%AF%B7%E6%B1%82%E3%80%81%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%E3%80%81%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","excerpt":"","text":"请求超时和网络异常处理前端设置 超时设置 12//超时设置xhr.timeout = 2000; 超时回调 123xhr.ontimeout = function()&#123; alert(&quot;网络异常，稍后重试&quot;);&#125; 网络异常回调 123xhr.onerror = function()&#123; alert(&quot;你的网络似乎出了点问题！&quot;);&#125; 后端设置123456789app.get(&#x27;/delay&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置定时器 setTimeout(()=&gt;&#123; response.send(&#x27;延时响应&#x27;); &#125;,3000) //设置响应体 &#125;); 取消请求前端设置利用abort函数 1xhr.abort()； 重复请求问题123456789101112131415161718let x = null;let isSending = false;//是否正在发送AJAX请求btn[0].onclick = function()&#123; //判断标识变量 if(isSending) x.abort(); //如果正在发送，则取消该请求，创建一个新的请求 x= new XMLHttpRequest(); //修改标识变量的值 isSending = true; x.open(&quot;GET&quot;,&quot;http://127.0.0.1:8000/delay&quot;); x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; //修改表示变量 isSending = false; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"服务端响应JSON数据","slug":"服务端响应JSON数据","date":"2021-09-10T12:33:49.000Z","updated":"2021-09-10T12:43:27.352Z","comments":true,"path":"2021/09/10/服务端响应JSON数据/","link":"","permalink":"http://daniellin0516.github.io/2021/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94JSON%E6%95%B0%E6%8D%AE/","excerpt":"","text":"响应JASON数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 3px #89b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const xhr = document.getElementById(&quot;result&quot;); window.onkeydown = function()&#123; //发送请求 const xhr = new XMLHttpRequest(); //设置响应体数据的类型 xhr.responseType = &quot;json&quot;; //初始化 xhr.open(&#x27;GET&#x27;,&#x27;http://127.0.0.1:8000/json-server&#x27;); //发送 xhr.send(); //事件绑定 xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; // console.log(xhr.response); // result.innerHTML = xhr.response; //1.手动对数据转化 // let data =JSON.parse(xhr.response); // console.log(data); // result.innerHTML = data.name; //2.自动转化 console.log(xhr.response); result.innerHTML = xhr.response.name; &#125; &#125; &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 传给服务器js文件 12345678910111213141516171819202122232425262728293031const express = require(&#x27;express&#x27;);//创建应用对象const app = express();//创建路由规则// request是对响应报文的封装//response是对响应报文的封装app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX&#x27;);&#125;);//可以接收任意类型的请求app.all(&#x27;/json-server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;); //响应一个数据 const data = &#123; name: &#x27;atguigu&#x27; &#125;; //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体 response.send(str);&#125;);//监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;)","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"原生AJAX发送请求","slug":"原生AJAX发送请求","date":"2021-09-10T07:24:52.000Z","updated":"2021-09-10T08:35:09.202Z","comments":true,"path":"2021/09/10/原生AJAX发送请求/","link":"","permalink":"http://daniellin0516.github.io/2021/09/10/%E5%8E%9F%E7%94%9FAJAX%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","excerpt":"","text":"GET请求1234567891011121314151617181920212223242526272829btn.onclick = function()&#123; //1.创建对象 const xhr = new XMLHttpRequest; //2.初始化 设置请求方法和url xhr.open(&#x27;GET&#x27;,&#x27;http://127.0.0:8000/server&#x27;); //3.发送 xhr.send(); //4.事件绑定 处理服务端返回的结果 //on when 当……时候 //readystate 是xhr对象中的属性，表示状态0 1 2 3 4 //change 改变 xhr.onreadyStatechange = function()&#123; //判断(服务端返回了所有结果) if(xhr.readyState === 4)&#123; //判断响应状态码 200 404 403 401 500 //2xx 成功 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; //处理结果 行 头 空行 体 //1.响应行 console.log(xhr.Status);//状态码 console.log(xhr.StatusText);//状态字符串 console.log(xhr.getAllResponseHeaders());//所有响应头 console.log(xhr.response);//响应体 &#125;else&#123; &#125; &#125; &#125; &#125;; 其中的server.js为下列代码： 1234567891011const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO EXPRESS&#x27;);&#125;);app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;) POST请求12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;AJAX POST&lt;/title&gt; &lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 1px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; //获取元素对象 const result = document.getElementById(&quot;result&quot;); //绑定事件 result.addEventListener(&quot;mouseover&quot;,function()&#123; //1.创建对象 const xhr = new XMLHttpRequest(); //2.初始化 设置类型与URL xhr.open(&#x27;POST&#x27;,&#x27;http://127.0.0.1:8000/server&#x27;); //3.发送 xhr.send(); //4.事件绑定 xhr.onreadystatechange = function()&#123; //判断 if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt;300)&#123; //处理服务端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其中的server.js为下列代码： 12345678910111213141516171819202122const express = require(&#x27;express&#x27;);//创建应用对象const app = express();//创建路由规则// request是对响应报文的封装//response是对响应报文的封装app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX&#x27;);&#125;);app.post(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);//监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;) POST设置请求体123xhr.send(&quot;a=100&amp;b=200&amp;c=300&quot;);//或者xhr.send(&quot;a:100&amp;b:200&amp;c:300&quot;);//传参非常灵活 在send()函数进行传递参数 则可以在网络看到传递的参数 AJAX设置请求头信息1234//设置请求头xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);//也可以去自定义xhr.setRequestHeader(&#x27;name&#x27;,&#x27;atguigu&#x27;); 而server.js也需要做出更改 12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;);//创建应用对象const app = express();//创建路由规则// request是对响应报文的封装//response是对响应报文的封装app.get(&#x27;/server&#x27;,(request, response)=&gt;&#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX&#x27;);&#125;);//可以接收任意类型的请求app.all(&#x27;/server&#x27;,(request, response)=&gt;&#123; //all可以接收任意类型的请求 //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;); //加这一行代码 //设置响应体 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);//监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000端口监听中……&quot;);&#125;) 不需要记住，会自动完成 经常利用setRequestHeader函数进行身份校验，传递给后端 Content-Type是来设置请求体内容的类型 application/x-www-form-urlencoded是给参数查询字符串的类型的固定写法","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"HTTP协议","slug":"HTTP协议","date":"2021-09-09T08:40:45.000Z","updated":"2021-09-09T11:45:59.602Z","comments":true,"path":"2021/09/09/HTTP协议/","link":"","permalink":"http://daniellin0516.github.io/2021/09/09/HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTPHTTP(hypertext transport protocol)协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则 请求报文重点是格式与参数： 行：POST /s?ie=utf–8 HTTP/1.1 头： HOST: atguigu.com Cookie: name=guigu Content-type: application/x-www-form-urlencoded User-Agent: chrome 83 空行： 体：username=admin&amp;password=admin 响应报文格式与参数： 行: HTTP/1.1 200（响应状态码，有404,403,401,500,200等） OK（响应状态字符串） 头: Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体: 123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"}]},{"title":"CSS方法写下拉菜单小三角","slug":"CSS方法写下拉菜单小三角","date":"2021-08-05T12:19:12.000Z","updated":"2021-08-05T12:46:11.447Z","comments":true,"path":"2021/08/05/CSS方法写下拉菜单小三角/","link":"","permalink":"http://daniellin0516.github.io/2021/08/05/CSS%E6%96%B9%E6%B3%95%E5%86%99%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E5%B0%8F%E4%B8%89%E8%A7%92/","excerpt":"","text":"小三角组成原理： 利用border给四个边框设置颜色如图所示： 若需要上箭头的话则要把border-top的属性设为none，左边和右边的属性设为transparent（透明色） 1234567.box1&#123; width: 0px; height: 0px; border: 20px solid transparent; border-top: none; border-bottom-color: tomato; &#125; 1234567891011121314li:hover &gt; .app::after&#123; content: &#x27;&#x27;; position: absolute; /*设置绝对定位使小三角上去*/ width: 0; height: 0; border: 8px solid transparent/*透明色*/; /*去除上边框*/ border-top: none ; border-bottom-color: white; bottom: 0; left: 0; /*使三角形居中*/ right: 0; margin: auto; &#125; 下拉菜单在有下拉菜单的父元素创建一个div块元素，根据需求调整大小，最重要的是display:none将模块隐藏，下面是小米二维码下拉菜单的一个例子： CSS 12345678910111213141516li:hover &gt; .app .qrcode &#123; display: block; &#125;/*设置app下载的下拉*/.app .qrcode&#123; display: none; position: absolute; /*开启绝对定位后不再占据位置*/ left: 22px; margin-left: -62px; width: 124px; height: 148px; background-color: white; line-height:1 ; text-align: center; box-shadow: 0 0 10px rgba(0, 0, 0, .3); HTML 12345678&lt;li&gt;&lt;a class=&quot;app&quot; href=&quot;ja:;&quot;&gt; 下载app &lt;!--添加一个弹出层--&gt; &lt;div class=&quot;qrcode&quot;&gt; &lt;img src=&quot;./img/download.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;小米商城app&lt;/span&gt; &lt;/div&gt; &lt;/a&gt;&lt;/li&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"背景和雪碧图","slug":"背景","date":"2021-08-02T09:18:10.000Z","updated":"2021-08-06T03:03:53.163Z","comments":true,"path":"2021/08/02/背景/","link":"","permalink":"http://daniellin0516.github.io/2021/08/02/%E8%83%8C%E6%99%AF/","excerpt":"","text":"背景background-image设置背景图片 1.可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色 2.如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满 3.如果背景的图片大于元素，将会一个部分背景无法显示 4.如果背景图片和元素一样大，则会直接正常显示 1background-image:url(); background-repeat 可选值： 1.repeat默认值，背景会沿着x轴，y轴双方向重复 2.repeat-x沿着x轴方向重复 3.repeat-y沿着y轴方向重复 4.no-repeat背景图片不重复 background-position用来设置背景图片的位置 设置方式： 1.通过 top left right bottom center 几个表示方位的词来设置背景图片位置 12background-position:center center ; //正中间background-position:top left ; //左上角 2.通过偏移量来指定背景图片的位置： 水平方向偏移量 垂直方向偏移量 1background-position:50px 50px; background-clip设置背景的范围 可选值： border-box默认值，背景会出现在边框的下边 padding-box 背景不会出现在边框，只出现在内容区和内边距 content-box背景只会出现在内容区 background-origin 背景图片的的偏移量计算的原点 padding-box默认值，background-position从内边距开始计算 content-box背景图片的偏移量从内容区计算 border-box背景图片的变量从边框开始计算 background-size 设置背景图片的大小 第一个值表示宽度 第二个值表示高度 如果只写一个，则第二个值默认是auto 1background-size：100% auto; 可选值： cover图片的比例不变，将元素铺满 contain图片比例不变，将图片在元素中完整显示 background-attachment背景图片是否跟随元素移动 可选值： scroll默认值，背景图片会跟随元素移动 fixed背景会固定在页面中，不会跟随元素移动 background背景图片的相关的简写属性，所有背景相关的样式都可以通过该样式来设置 并且该样式没有顺序要求，也没有哪个属性是必须写的 注意： background-size必须写在background-position后边，并且使用/隔开 1background-position/background-size background-origin background-clip两个样式，origin要在clip前边 超链接按钮的背景设置12345678910111213&lt;style&gt;a:link&#123; display:block; width:93px; height:29px; background-image:url();&#125;a:hover&#123; background-position:-93px 0;&#125;a:active&#123; background-position:-186px 0;&#125; 解决图片闪烁的问题： 可以将多个小图片同意保存到一个大图片中，然后通过调整background-position来显示，这样图片会同时加载到网页中，就可以有效的避免出现闪烁的问题，这个技术在网页中应用十分广泛，被称为CSS-Sprite，叫雪碧图 雪碧图使用步骤： 先确定要使用的图形 测量图标大小 根据测量结果创建一个元素 将雪碧图设置为元素的背景图片 设置一个偏移量以显示正确的图片 雪碧图特点： 一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户的体验 颜色的渐变线性渐变 background-image 线性渐变，颜色沿着一条直线发生变化 可选值： liner-gradient() 1background-image:liner-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区，线性渐变的开头，我们可以指定一个渐变的方向 to left to right to bottom to top xxxdeg（表示度数） turn表示圈 渐变可以同时制定多种颜色，多个颜色默认情况下平均分布，也可以手动指定简便的分布情况 1234567&lt;style&gt; .box1&#123; width: 200px; height: 220px; background-image: linear-gradient(to left,red 50px,yellow 100px); &#125;&lt;/style&gt; repeating-linear-gradient() 可以平铺的线性渐变 径向渐变 background-image: 可选值： radial-gradient 默认情况下径向渐变圆心的形状根据元素的形状来计算的： 正方形—&gt;圆形 长方形—-&gt;椭圆形 我们也可以手动指定径向渐变大小 circle ellipse 1234567&lt;style&gt; .box1&#123; width: 200px; height: 220px; background-image:radial-gradient(circle at center,red,yellow); &#125;&lt;/style&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"文本的水平和垂直对齐","slug":"文本的水平和垂直对齐","date":"2021-07-30T09:30:25.000Z","updated":"2021-07-30T09:59:53.762Z","comments":true,"path":"2021/07/30/文本的水平和垂直对齐/","link":"","permalink":"http://daniellin0516.github.io/2021/07/30/%E6%96%87%E6%9C%AC%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%AF%B9%E9%BD%90/","excerpt":"","text":"文本的水平对齐 text-align 可选值： left 左侧对齐 right 右侧对齐 bottom 底部对齐 middle 居中对齐 12345678&lt;style&gt; div&#123; width: 200px; border: 1px red solid; font-size: 50px; text-align: left; &#125;&lt;/style&gt; 设置元素垂直对齐的方式 vertical-align 可选值： baseline 默认值 基线对齐 top 顶部对齐 bottom 底部对齐 middle 居中对齐 其他文本样式文本修饰 text-decoration 可选值： none 什么都没有 underline 下划线 line-through 删除线 overline 上划线 1234.box1&#123; text-decoration:underline red; &#125; 文本显示 white-space 可选值： normal 正常 nowrap 不换行 pre 保留空白 12345678&lt;style&gt; .box1&#123; width: 100px; white-space: nowrap; overflow: hidden; /*超出宽度不显示*/ text-overflow:ellipsis; /*出现省略号*/ &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;今天天气真不错&lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"简单布局和高度塌陷以及BFC","slug":"简单布局和高度塌陷以及BFC","date":"2021-07-28T06:52:15.000Z","updated":"2021-07-29T06:54:03.456Z","comments":true,"path":"2021/07/28/简单布局和高度塌陷以及BFC/","link":"","permalink":"http://daniellin0516.github.io/2021/07/28/%E7%AE%80%E5%8D%95%E5%B8%83%E5%B1%80%E5%92%8C%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E4%BB%A5%E5%8F%8ABFC/","excerpt":"","text":"页面的简单布局123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; header,main,footer&#123; width: 1000px; margin: 0 auto; &#125; /*设置头部*/ header&#123; height:150px; background-color: silver; &#125; main&#123; height: 500px; background-color: #bfa; margin: 10px auto; &#125; nav&#123; width: 190px; height: 100%; background-color: yellow; float: left; &#125; article&#123; width: 600px; height: 100%; background-color: orange; float: left; margin:0 10px; &#125; aside&#123; width: 190px; height: 100%; background-color: pink; float: left; &#125; footer&#123; height: 150px; background-color: tomato; &#125;&lt;/style&gt; 下面是html基本写法： 123456789&lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt; 效果图： 高度塌陷1234567891011&lt;style&gt; .outer&#123; border: 10px red solid; &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; 123456&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 效果图： 里面的方块不随外面边框浮动，这就是高度塌陷 高度塌陷的问题： 在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失 父元素高度丢失后，其下的元素会自动上移，导致页面的布局混乱 所以高度塌陷是浮动布局中比较常见的一个问题，这个问题要处理 BFCBFC（Block Formatting Content）块级格式化环境 BFC是一个CSS中的一个隐含的属性，可以设为一个元素开启BFC 开启BFC该元素会变成一个独立的布局区域 元素开启BFC后的特点： 1.开启BFC的元素不会被浮动元素所覆盖 2.开启BFC的元素子元素和父元素外边距不会重叠 3.开始BFC的元素可以包含浮动的子元素 可以通过一些特殊方式来开启元素的BFC： 1.设置元素的浮动（不推荐）123456789101112&lt;style&gt; .outer&#123; border: 10px red solid; float:left /*添加浮动*/ &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; 副作用：宽度会丢失 2.将元素设置为行内块元素（不推荐）123456789101112&lt;style&gt; .outer&#123; border: 10px red solid; display:inline-block; &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; 3.将元素的overflow设置为一个非visible的值常用的方式，为元素试着overflow：hidden开启其BFC以使其可以包含浮动元素 123456789101112&lt;style&gt; .outer&#123; border: 10px red solid; overflow:hidden; &#125; .inner&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125;&lt;/style&gt; clear作用：清除浮动元素对当前元素产生的影响 可选值： left：清除左侧浮动元素对当前元素的影响 1234567891011121314.box1&#123; width:200px; height:200px; background-color:blue; font-size:50px; float: left;&#125;.box3&#123; width: 200px; height: 200px; background-color: purple; font-size: 50px; clear:left; /**清除box1浮动带来的影响，否则数字会环绕在box1旁边**/&#125; 用clear:left清除box1带来的浮动影响](https://imgtu.com/i/WHolRg) right：清除右侧浮动元素对当前元素的影响 123456789101112131415161718192021.box1&#123; width:200px; height:200px; background-color:blue; font-size:50px; float: left; &#125; .box2&#123; width: 400px; height: 400px; background-color: yellow; font-size: 50px; float:right; &#125; .box3&#123; width: 200px; height: 200px; background-color: purple; font-size: 50px; clear:right /**清除box2带来的浮动影响**/ &#125; both:清除两侧中最大影响的那侧 原理： 设置清除浮动以后，浏览器会自动为元素添加一个上外边距，以使其位置不受其他元素的影响 高度塌陷最终解决方法（最佳）运用伪元素::after 1234567891011121314151617&lt;style&gt; .box1&#123; border: 10px red solid; &#125; .box2&#123; width: 200px; height: 200px; background-color: #bfa; float: left; &#125; .box1::after&#123; content: &quot;&quot;; display: block; clear:both; &#125;&lt;/style&gt; 12345&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 会根据内容高度而改变 Clearfix（重要）这个样式可以同时解决高度塌陷和外边距重叠的问题，当你再遇到这些问题时，直接使用clearfix 1234567891011121314151617&lt;style&gt; .box1&#123; border: 10px red solid; &#125; .box2&#123; width: 200px; height: 200px; background-color: #bfa; float: left;&#125; .clearfix::before, .clearfix::after&#123; content: &quot;&quot;; display: table; clear: both; &#125;&lt;/style&gt; 123456&lt;body&gt; &lt;div class=&quot;box1 clearfix&quot; &gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"浮动","slug":"浮动","date":"2021-07-28T01:49:18.000Z","updated":"2021-07-29T01:40:59.967Z","comments":true,"path":"2021/07/28/浮动/","link":"","permalink":"http://daniellin0516.github.io/2021/07/28/%E6%B5%AE%E5%8A%A8/","excerpt":"","text":"浮动通过浮动可以使一个元素向其父元素的左侧或右侧移动 使float属性来设置于元素的浮动 可选值： none 默认值，元素不浮动 left 元素向左移动 right 元素向右移动 注意： 元素设置浮动以后，会完全从文档中脱离，不在占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动 浮动的特点 1.浮动元素会完全脱离文档流，不再占据文档流中的位置 2.设置浮动以后元素会向父元素的左侧或右侧移动 3.浮动元素默认不会从父元素中移除 4.浮动元素向左或向右移动时，不会超过它前边的其他浮动元素 5.如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移 6.浮动元素不会超过它上边的浮动兄弟元素，最多最多就是和它一样高 总结： 浮动目前来讲他的作妖作用时让页面水平排列，通过浮动可以制作一些水平方向的布局 1234567891011121314 &lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: #bfa; float:left; &#125; .box2&#123; width: 100px; height:100px; background-color: rgb(33, 16, 185); float: left; &#125;&lt;/style&gt; 12345&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/body&gt; 效果图： 浮动的特点 1.浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以利用浮动来设置文字环绕图片的效果 2.元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化： 脱离文档流的特点： 块元素： 1.块元素不在独占页面的一行 2.脱离文档流以后，块元素的宽度和高度默认都被内容撑开 行内元素： 1.行内元素脱离文档流以后会变成块元素，特点和块元素一样 脱离文档流以后，不需要再区分块和行内了","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"盒子模型","slug":"盒子模型","date":"2021-07-24T14:37:52.000Z","updated":"2021-07-29T01:40:47.289Z","comments":true,"path":"2021/07/24/盒子模型/","link":"","permalink":"http://daniellin0516.github.io/2021/07/24/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"盒子模型每一个盒子由以下部分组成：(一共盒子的可见框的大小由内容区，内边距，边框共同决定，所以在计算盒子大小时，需要将三个区域加到一块计算) 内容区（content）内容区大小由width和height属性设置 width：设置内容区的宽度 height：设置内容区的高度 内边距（padding） 内容区和边框之间的距离是内边距,，内边距设置会影响盒子大小 背景颜色会延申到内边距上 12345678&lt;style&gt;.box1&#123; width:200px; height:200px; background-color:green; border:10px orange solid; padding-top:200px;&#125; 一共有四个方向的内边距 padding-top padding-right padding-bottom padding left padding简写属性：可以同时指定四个方向的内边距，规则和border-width一样 1234padding:10px 20px 30px 40px;padding:10px 20px 30px;padding:10px 20px;padding:10px; 边框（border）边框属于盒子的边缘，边框里面属于盒子的内容，出了边框都是盒子的外部，边框的大小会影响到整个盒子的大小，要设置边框，需要至少设置三个样式： 边框的宽度：border-width 值的情况： 四个值（顺时针）：上 右 下 左（例如border width：10px 20px 30px 40px；） 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 除了border-width还有一组border-xxx-width xxx可以是top right bottom left 用来单独指定摸一个边的宽度 边框的颜色：border color 同样可以分别指定4个边框的颜色规则和border一样，默认值为黑色 边框的样式：border-style 指定边框样式，solid表示实线，dotted点状虚线，dashed虚线，double双线 border以及boder-xxx简写属性：10px solid orange；（无顺序要求） 外边距（margin）不会影响可见框的大小，会影响盒子所在位置 一共由四个方向的外边距： margin-top： 上外边距，设置一个正值，元素会向下移动 margin-right margin-bottom： 下外边距，设置一个正值，其下边的元素会向下移动 margin-left： 左外边距，设置一个正值，元素会向右移动 margin也可以设置负值，如果是负值则元素会向相反的方向移动 magin简写属性： margin可同时设置4个方向的外边距，用法和padding一样 margin会影响到盒子的实际占用空间 盒子模型-水平方向的布局元素的水平方向的布局： 元素在其父元素的水平方向的位置由以下几个属性共同决定： margin-left border-left padding-left width padding-right border-right margin-right 一个元素在其父元素中，水平布局必须要满足以下的等式： margin-left+border-left+padding-left+width+padding-right+border-right+margin-right=其父元素内容的宽度（必须满足） 调整情况： 1.如果这7个值中没有设为auto的情况，则浏览器会自动调整margin-right 这七个值中有三个值可以设置为auto： width margin-left margin-right 如果某个值为auto，则会自动调整为auto那个值以使等式成立 0+0+0+auto+0+0+0=800 auto=800 如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为aut0 如果将三个都设置为auto，则外边距都是0，宽度最大 如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值，所以我们经常利用这个特点来使一个元素在其父元素中水平居中 示例： 12width:xxxpx;margin:0 auto; 垂直方向的布局123456789101112&lt;style&gt; .box1&#123; width:200px; height:200px; background-color: chartreuse; &#125; .box2&#123; width: 100px; height:250px; background-color: coral; &#125; &lt;/style&gt; 1234&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 运行后结果： 子元素是在父元素的内容区中排列的： 如果子元素的大小超过了父元素，则子元素会从父元素中溢出使用overflow属性来设置父元素如何处理溢出的子元素 overflow可选值： visible：默认值，子元素会从父元素中溢出，在父元素外部的位置显示 hidden：溢出内容将会被裁剪不会显示 scroll：生成两个滚动条，通过滚动条来查看完整内容 auto：根据需要生成滚动条 12345678910111213&lt;style&gt; .box1&#123; width:200px; height:200px; background-color: chartreuse; overflow:hidden; /*在父元素下面写overlow*/ &#125; .box2&#123; width: 100px; height:250px; background-color: coral; &#125; &lt;/style&gt; overflow-x：处理水平方向溢出 overflow-y：处理竖直方向溢出 外边距的折叠相邻的垂直方向外边距会发生重叠现象 兄弟元素 兄弟元素间的相等垂直外边距会取两者之间的较大值（两者都是正值） 特殊情况： 如果相邻的外边距一正一负，则取两者的和 如果相邻的外边距都是负值，则取两者中绝对值较大的 兄弟元素之间的外边距重叠，对于开发使有利的，所以我们不需要进行处理 1234&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt; 父子元素 父子元素间相邻外边距，子元素的会传递给父元素（上外边距） 父子外边距的折叠会影响到页面的布局，必须要进行处理1.利用padding-top 123456&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 行内元素的盒模型行内元素不支持设置宽度和高度 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局 行内元素可以设置border，垂直方向的border不会影响页面的布局 行内元素可以设置margin，垂直方向的border不会影响页面的布局 display用来设置元素显示的类型： 可选值： inline：将元素设行内元素 block:将元素设置为块元素 inline-block：行内块元素（可放置宽高又不会独占一行） table：将元素设为一个表格 none:元素不在页面显示 visibility用来设置元素的显示状态： 可选值： 12345678910111213```hidden```：元素在页面隐藏，不显示，但是依然占据页面位置## 盒子的尺寸大小```css.box1&#123; width:100px; height:100px; backgroud-color:#bfa; padding:10px; border:10px red solid;&#125; 默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定（上述代码可见框140px） box-sizing：用来设置尺寸的计算方式（设置width和height的作用） 可选值： content-box：默认值，宽度和高度用来设置内容区的大小 border-box：宽度和高度用来设置整个盒子可见框的大小 ​ width和height指的是内容区和内边距和边框的大小 12345678.box1&#123; width:100px; height:100px; backgroud-color:#bfa; padding:10px; border:10px red solid; box-sizing:border-box&#125; 上述代码则为100px×100px的可见框大小，会自动缩小内容区的大小 轮廓阴影和圆角轮廓线outline：用来设置元素的轮廓线，用法和border一模一样 轮廓线不会影响到可见框的大小 123456.box1&#123; width:100px; height:100px; background-colorblue; outline:10px red solid;&#125; 123456.box1&#123; width:100px; height:100px; background-color:blue; border:10px red solid;&#125; ​ outline（左）和border（右）的区别 阴影box-shadow:用来设置元素的阴影效果，阴影不会影响页面的布局 第一个值：水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动 第二个值：垂直偏移量 设置阴影的垂直位置 正值向下移动 负值向上移动 第三个值：阴影的模糊半径，像素越大越模糊 第四个值：阴影的颜色 123456789&lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: blue; box-shadow:10px 10px 10px rgba(0, 0,0, 0.5); &#125; &lt;/style&gt; 效果图： 圆角border-radius：用来设置与圆角 border-top-left-radius: border-top-right-radius border-bottom-left-radius border-bottom-right-radius border-radius可以分别指定四个角的圆角 四个值：左上 右上 右下 坐下 三个值：左上 右上/左下 右下 两个值：左上/右下 右上/左下 将图形设置为圆形： 1border-radius:50%;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"选择器","slug":"选择器","date":"2021-07-22T10:32:01.000Z","updated":"2021-08-03T01:53:01.614Z","comments":true,"path":"2021/07/22/选择器/","link":"","permalink":"http://daniellin0516.github.io/2021/07/22/%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"常用选择器1.元素选择器123456p&#123; color=red;&#125;h1&#123; color=red;&#125; 2.id选择器根据id属性选中一个元素 12345&lt;style&gt;#red&#123; color:red;&#125;&lt;/style&gt; 12345&lt;body&gt; &lt;p id=&quot;red&quot;&gt; &lt;/p&gt;&lt;/body&gt; 3.class选择器class可重复，id不可重复 12345&lt;style&gt;.blue&#123; color:blue;&#125;&lt;/style&gt; 12345&lt;body&gt; &lt;p class=&quot;red&quot;&gt; &lt;/p&gt;&lt;/body&gt; 复合选择器1.交集选择器作用：选中同时复合多个条件的元素 语法：选择器1选择器2选择器3选择器n{} 注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头 1234567891011&lt;style&gt;.red&#123; color:red;&#125;div.red&#123; font-size:30px;&#125;.a.b.c&#123; color:blue;&#125;&lt;/style&gt; 1234567891011&lt;body&gt; &lt;div class=&quot;red&quot;&gt; 我是div &lt;/div&gt; &lt;p class=&quot;red&quot;&gt; 我是p &lt;/p&gt; &lt;div class=&quot;red2 a b c&quot;&gt; 我是div2 &lt;/div&gt;&lt;/body&gt; 下面是这段代码的图片： 选择器分组作用：同时选择多个选择器对应的元素 语法：选择器1，选择器2，选择器n{} 12345&lt;style&gt;h1,span&#123; color:green;&#125;&lt;/style&gt; 关系选择器 父元素：直接包含子元素的元素叫做父亲 子元素：直接被父元素包含的元素是子元素 祖先元素：直接或间接包含后代元素的元素叫做祖先元素 ​ 一个元素的父元素也是它的祖先元素 后代元素：直接或间接被祖先元素包含的元素叫做后代元素 ​ 子元素也是后代元素 兄弟元素：拥有相同父亲元素是兄弟元素 下面都是在这个html进行的例子： 12345678910&lt;body&gt; &lt;div&gt; 我是一个div &lt;p&gt; 我是div中的p元素 &lt;span&gt;我是p元素的span&lt;/span&gt; &lt;/p&gt; &lt;span&gt;我是div中的span元素&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; 1.子元素选择器作用：选定父元素的指定子元素 语法：父元素&gt;子元素（可用class选择元素） 例子：为div的子元素span设置一个字体颜色红色（为div直接包含的span设置一个字体红色） 12345&lt;style&gt;div&gt;span&#123; color:red;&#125;&lt;/style&gt; 2.后代选择器 作用：选中指令元素内的指定后代元素 语法：祖先 后代 12345&lt;style&gt;div span&#123; color:red;&#125;&lt;/style&gt; 3.兄弟选择器语法：前一个+子元素(找紧挨着的元素)（选择下一个兄弟） 12345&lt;style&gt;p+span&#123; color:red;&#125;&lt;/style&gt; 选择下面所有兄弟： 12345&lt;style&gt;p~span&#123; color:red;&#125;&lt;/style&gt; 属性选择器语法：[属性名]选择含有指定属性的元素 ​ [属性名=属性值]选择含有指定属性和属性值的元素 ​ [属性名^=属性值]选择属性值以指定值开头元素 ​ [属性名$=属性值]选择属性值以指定值结尾元素 ​ [属性名*=属性值]选择属性值中含有某值的元素 12345&lt;style&gt;p[title=abc]&#123; color:red;&#125;&lt;/style&gt; 12345&lt;body&gt; &lt;p title=&quot;abc&quot;&gt; 1111 &lt;/p&gt;&lt;/body&gt; 伪类选择器伪类用来描述一个元素的特殊状态 比如：第一个元素、被点击的元素，鼠标移入的元素 伪类一般：开头 1.:first-child第一个子元素 12345&lt;style&gt;ul&gt;li:first-child&#123; color:red;&#125;&lt;/style&gt; 123456789&lt;body&gt; &lt;ul&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 2.:last-child最后一个子元素 3.nth-child(n)选中第n个子元素 nth-child(2)选第二个子元素 特殊值： n 第n个 n的范围：0到正无穷 2n（even） 偶数位元素 2n+1（odd）奇数位元素 4.:first-of-type :last -of-type :nth-of-type这几个伪类的功能和上述的类似，不通点是他们是在同类型中进行排序 12345&lt;style&gt;ul&gt;li:first-of-type&#123; color:red;&#125;&lt;/style&gt; 12345678910&lt;body&gt; &lt;ul&gt; &lt;span&gt;11&lt;/span&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 5.:not()否定伪类，将符合条件元素从选择器去除 12345&lt;style&gt;ul&gt;li:not(:nth-child(3))&#123; color:red;&#125;&lt;/style&gt; 将第三个子元素去除掉，其他全为红色 超链接伪类1.:link用来表示没访问过的链接（正常的链接） 2.:visited用来表示访问过的链接 3.:hover表示鼠标移入状态 4.：active表示鼠标点击 伪元素选择器伪元素通常使用::开头 1.::first-letter表示第一个字母 12345&lt;style&gt;p::first-letter&#123; font-size:90px;&#125;&lt;/style&gt; 会使文本第一个字母放大 2.::first-line表示第一行 3.::selection表示选中的内容（需要鼠标拖动） 4.::before元素的开始的位置，必须结合content属性使用 12345&lt;style&gt;div::before&#123; content:&#x27;abc&#x27;; color:red;&#125; 12345&lt;body&gt; &lt;div&gt; hello &lt;/div&gt;&lt;/body&gt; 5.::after元素的最后的位置，必须结合content属性使用","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"CSS修改元素样式和语法","slug":"CSS修改元素样式和语法","date":"2021-07-22T05:58:02.000Z","updated":"2021-07-29T01:41:58.094Z","comments":true,"path":"2021/07/22/CSS修改元素样式和语法/","link":"","permalink":"http://daniellin0516.github.io/2021/07/22/CSS%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%92%8C%E8%AF%AD%E6%B3%95/","excerpt":"","text":"使用css修改元素样式1.第一种 内联样式，行内样式（不推荐使用，只能对一个标签生效） 在标签内部通过style属性设置元素样式 1&lt;p style=&quot;color:red font-size:20px&quot;&gt;&lt;/p&gt; 2.第二种 内部样式表（方便更改，使用，只能对一个网页作用） 1234567&lt;head&gt;&lt;style&gt;p&#123; color:&quot;green&quot;&#125;&lt;/style&gt;&lt;/head&gt; 3.第三种 外部样式表（加快网页加载速度，提高用户体验） 将css样式编写到一个外部的CSS文件中 通过link标签引入外部css文件 CSS语法 基本语法：选择器 声明块 选择器：可选中页面指定元素，比如p作用就是选中页面所有p元素 声明块：通过声明块来指定为元素设置样式","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"HTML","slug":"HTML-1","date":"2021-07-20T06:00:51.000Z","updated":"2021-08-17T02:15:46.582Z","comments":true,"path":"2021/07/20/HTML-1/","link":"","permalink":"http://daniellin0516.github.io/2021/07/20/HTML-1/","excerpt":"","text":"网页结构W3C标准 结构：HTML用于描述页面结构 表现：CSS用于控制页面中元素的样式 行为：JavaScript用于响应用户操作 HTML结构123456789101112&lt;!DOCTYPE html&gt; &lt;!--html5的文档声明--&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; HTML实体的语法1.&amp;nbsp;表示一个空格 2.gt;表示一个大于号 3.lt;表示一个小于号 4.copy;表示版权符号 标签1.meta标签属性： name：指定的数据名称（关键词） http-equiv:将页面重定向到另一个网站 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=http://baidu.com&quot;&gt; 过三秒后会定向到百度页面 content:指定的数据内容 keywords 1&lt;meta name=&quot;keywords&quot; content=&quot;购物&quot;&gt; 在搜索引擎搜索购物即可搜到该页面 description 1&lt;meta name=&quot;description&quot; content=&quot;****&quot;&gt; 用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中，如图所示： 2.语义化标签2-1标题标签 h标签（块元素） 123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 从h1到h6重要性递减，h1最重要，h6最不重要 p标签（块元素） 1&lt;p&gt;在p标签内容表示一个段落&lt;/p&gt; hgrourp标签 12345678&lt;hgroup&gt; &lt;h1&gt; 回乡偶书 &lt;/h1&gt; &lt;h2&gt; 其一 &lt;/h2&gt;&lt;/hgroup&gt; 用来为标题分组，可以将一组相关标题同时放入hgroup里 em标签（行内元素） 1&lt;p&gt;今天&lt;em&gt;天气&lt;/em&gt;真好&lt;/p&gt; 表示语音语调的一个加重 strong标签（行内元素） 加粗字体，强调 blockquote标签（块元素） 长引用，通常用来表达名人名言 q标签（行内元素） 短引用，表达名人名言不会换行 br标签（块元素） 换行用，独占一行 2-2布局标签1&lt;header&gt;：表示网页头部2.&lt;main&gt;:表示网页的主题部分（一个页面只有一个）3.&lt;footer&gt;:表示网页底部4.&lt;nav&gt;:表示网页的导航5.&lt;aside&gt;:和主体相关其他内容（侧边栏） 6.&lt;article&gt; ：独立文章 7.&lt;section&gt;:表示一个独立区块，上边的标签都不能使用section 8.&lt;div&gt;:没语义，用来表示一个区块，div还是主要布局元素，块元素 9.&lt;span&gt;:行内元素，没有任何语义，一般用于在网页中选中文字 2-3列表标签一.分类1.无序列表使用ul标签创建有序列表，使用li表示列表项 1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 2.有序列表使用ol标签创建有序列表，使用li表示列表项 1234&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 3.定义列表使用dl标签创建有序列表，使用dt表示列表项 二.嵌套12345678&lt;ul&gt; &lt;li&gt;aa &lt;ul&gt; &lt;li&gt;aa-1&lt;/li&gt; &lt;li&gt;aa-2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 如下图所示： 2-4超链接 &lt;a&gt;&lt;/a&gt;(行内元素) 属性： href:目标路径 1&lt;a href=&quot;https：//www.baidu.com&quot;&gt;超链接&lt;/a&gt; 相对路径都会使用.或..开头 ./表示当前文件所在目录 .//表示当前文件所在目录的上一级目录 targrt：用来指定超链接打开位置 可选值：_self 默认值，在当前页面打开超链接 ​ _blank 在一个新的页面打开超链接 1&lt;a href=&quot;https：//www.baidu.com&quot; target=&quot;_blank&quot;&gt;超链接&lt;/a&gt; id：可以跳转到页面指定位置，只需将href属性设置#目标关系，id唯一不重复 1&lt;a id=&quot;bottom&quot; href=&quot;#&quot;&gt;最底部&lt;/a&gt; ==另：== 1&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; 用JavaScript作为href属性，点击超链接不会发生 2-5图片标签 img标签（自结束标签） src属性：指定外部图片路径（路径规则和超链接是一样的） 1&lt;img src=&quot;&quot;&gt; alt属性：图片描述，描述默认不会显示，无法加载的时候显示，类似关键词 width属性：图片宽度（单位是像素） heigh属性：图片高度 2-6内联框架 iframe标签 src属性：指定引入网页的路径 frameborder：指定内联框架边框 2-7音视频1.音频 audio标签 属性： controls:是否允许用户控制播放 autoplay：音频文件是否自动播放 loop：循环 1&lt;audio src=&quot;***.mp3 contrlos autoplay&quot;&gt;&lt;/audio&gt; 2.视频 vedio标签 使用方式和audio一样 form标签 提交框： 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/form&gt; 文本框： 注意：数据要提交到服务器中，必须为元素设定一个name属性值 123&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/form&gt; 密码框： 123&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;username&quot;&gt;&lt;/form&gt; 单选按钮 1234&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;b&quot; checked&gt;&lt;/form&gt; 多选按钮 1234&lt;form action=&quot;xxx.html&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;username&quot; value=&quot;1&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;username&quot; value=&quot;2&quot; checked&gt;&lt;/form&gt; 下拉列表 1234567&lt;form&gt; &lt;select name=&quot;haha&quot;&gt; &lt;option value=&quot;1&quot;&gt;选项一&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;选项二&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;选项三&lt;/option&gt; &lt;/select&gt;&lt;/form&gt;","categories":[],"tags":[{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"}]},{"title":"Markdown基本用法","slug":"Markdown基本用法","date":"2021-07-20T01:06:45.000Z","updated":"2021-07-29T01:41:12.719Z","comments":true,"path":"2021/07/20/Markdown基本用法/","link":"","permalink":"http://daniellin0516.github.io/2021/07/20/Markdown%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"","text":"代码块1```+语言(java) 标题1234561.# 一级标题2.## 二级标题3.### 三级标题4.#### 四级标题5.##### 五级标题6.###### 六级标题 字体123456781.加粗 **内容**2.代码高亮显示`内容`3.删除线~~内容~~4.斜体*内容* 1.加粗内容2.代码高亮显示内容 3.删除线内容4.斜体内容 引用123&gt;内容&gt;&gt;内容&gt;&gt;&gt;内容 内容 内容 内容 分割线12--- //分割线1*** //分割线2 图片插入在线图片/本地图片 1![我的照片](照片链接) 列表无序列表 123- 目录一- 目录二- 目录三 目录一 目录二 目录三 有序列表 1231. 名称2. 名称3. 名称 名称 名称 名称 表格鼠标右键： 插入表格即可","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://daniellin0516.github.io/tags/Markdown/"}]},{"title":"Github+Hexo搭建个人博客","slug":"HTML","date":"2021-07-18T10:34:52.000Z","updated":"2021-07-29T01:41:37.745Z","comments":true,"path":"2021/07/18/HTML/","link":"","permalink":"http://daniellin0516.github.io/2021/07/18/HTML/","excerpt":"","text":"准备工作 (Node.js (nodejs.org))下载nodejs LTS版本 (Git - Downloads (git-scm.com))下载git 第一步 win+R启动，以管理员身份运行（windows系统自动会切到root用户） 在命令行输入： 1npm install -g cnpm --registry=https://registry.npm.taobao.org ​ 下载淘宝镜像源，稍等几秒 安装hexo框架，在命令行输入： 12cnpm install -g hexo-cli//安装完成之后可以输入hexo -v看版本 查看文件夹，并在该文件夹创建blog文件夹，进入blog文件夹 1234pwd //查看文件夹mkdir blog //创建文件夹cd blog/ //进入文件夹pwd //查看下路径对不对 用hexo生成博客 1hexo init 启动博客 1hexo s //进入本端给的地址 将我们自己的博客部署到github上公开使用 进入github之后，点击右上角 注意 例如我的是：DanielLin0516.github.io 在blog目录下安装一个git部署的插件 在命令行输入： 12pwd //查看路径cnpm install --save hexo-deployer-git 去设置_config.yml文件 1notepad _config.yml //用记事本去改Deoloyment里面的东西 type: git（注意前面要空一格） repo: （复制自己github上面的地址，前面空一格） branch： master 保存后退出即可 部署到远端 1hexo d 输入账号密码即可 这时刷新gitub仓库会多了很多内容 这样就成功部署到github上面了！！ 更改主题 去github去找主题 将git clone内串代码复制到命令行进行下载主题，会下载到theme这个文件夹里 在命令行输入： 1notepad _config.yml ​ 去更改记事本里面的theme：***即可 在本端进行查看，若可以的话直接上传到github上面123hexo ghexo shexo d","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://daniellin0516.github.io/tags/Blog/"}]}],"categories":[],"tags":[{"name":"项目总结分析","slug":"项目总结分析","permalink":"http://daniellin0516.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"},{"name":"webpack","slug":"webpack","permalink":"http://daniellin0516.github.io/tags/webpack/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://daniellin0516.github.io/tags/NodeJs/"},{"name":"ES6","slug":"ES6","permalink":"http://daniellin0516.github.io/tags/ES6/"},{"name":"JavaScript数据结构和算法","slug":"JavaScript数据结构和算法","permalink":"http://daniellin0516.github.io/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"Git","slug":"Git","permalink":"http://daniellin0516.github.io/tags/Git/"},{"name":"Ajax","slug":"Ajax","permalink":"http://daniellin0516.github.io/tags/Ajax/"},{"name":"HTML&&CSS","slug":"HTML-CSS","permalink":"http://daniellin0516.github.io/tags/HTML-CSS/"},{"name":"Markdown","slug":"Markdown","permalink":"http://daniellin0516.github.io/tags/Markdown/"},{"name":"Blog","slug":"Blog","permalink":"http://daniellin0516.github.io/tags/Blog/"}]}